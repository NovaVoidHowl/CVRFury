// { "version": "0.0.193" , "canInstall": true , "optional": true , "defineSymbolSuffix": "_MI_AL", dependencies: [], type: "Editor"}
// #if UNITY_EDITOR && CVR_CCK_EXISTS

using Math = System.Math;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System.IO;
using System.Text.RegularExpressions;
using UnityEditor;
using UnityEditor.Animations;
using UnityEditor.UIElements;
using UnityEngine;
using UnityEngine.UIElements;
using UnityEngine.SceneManagement;
using uk.novavoidhowl.dev.cvrfury.runtime;
using ABI.CCK.Scripts.Editor;
using ABI.CCK.Scripts;
using ABI.CCK.Components;
using Constants = uk.novavoidhowl.dev.cvrfury.packagecore.Constants;
using static uk.novavoidhowl.dev.cvrfury.packagecore.CoreUtils;
using static uk.novavoidhowl.dev.cvrfury.deployable.ReportBuilderSupport;
using static uk.novavoidhowl.dev.cvrfury.supporting_classes.editor.Animation;
using static uk.novavoidhowl.dev.cvrfury.supporting_classes.runtime.General;

// temp using for testing
using System.Text;

/// <summary>
/// armatureLink Module
/// this is handles binding objects to the armature of the avatar and merging addon armatures
/// </summary>

namespace uk.novavoidhowl.dev.cvrfury.deployable
{
  public class armatureLinkModuleProcessor : IModuleProcessor
  {
    public void ProcessModule(CVRFuryModule module, GameObject targetAvatar, int DSUNumber, GameObject DSUObject)
    {
      // Implementation for armatureLinkModuleProcessor
      // console print to say this function is being called
      CoreLog("armatureLinkModuleProcessor.ProcessModule() called");

      // log the module's moduleType to the console
      CoreLog("module.ModuleType: " + module.ModuleType);

      // cast the module to a armatureLinkModule
      armatureLink armatureLinkModule = (armatureLink)module;

      // get the modules from the DSU on the DSUObject
      List<CVRFuryModule> modules = DSUObject.GetComponent<CVRFuryDataStorageUnit>().modules.modules;

      // debug print the number of modules on the DSUObject
      CoreLogDebug("[Armature Link] modules.Count: " + modules.Count);

      // int to store the number of armatureLink modules on the DSUObject
      int armatureLinkModuleCount = 0;

      // loop over the modules and count the number of armatureLink modules
      foreach (CVRFuryModule m in modules)
      {
        //debug print the moduleType of the module
        CoreLogDebug("[Armature Link] m.ModuleType: " + m.ModuleType);
        if (m.ModuleType == "ArmatureLink")
        {
          armatureLinkModuleCount++;
        }
      }

      // print the armatureLinkModuleCount
      CoreLog("[Armature Link] armatureLinkModuleCount: " + armatureLinkModuleCount);

      // if there is more than one armatureLink module on the DSUObject
      if (armatureLinkModuleCount > 1)
      {
        // log a error to the console
        CoreLogError(
          "More than one armatureLink module found on DSUObject, this may cause issues, attempting automatic resolution"
        );

        // loop over the modules and get the ones that are armatureLink modules
        List<armatureLink> armatureLinkModules = new List<armatureLink>();
        foreach (CVRFuryModule m in modules)
        {
          if (m.ModuleType == "ArmatureLink")
          {
            armatureLinkModules.Add((armatureLink)m);
          }
        }

        // debug print the number of armatureLink modules
        CoreLogDebug("[Armature Link] armatureLinkModules.Count: " + armatureLinkModules.Count);

        // loop over the armatureLink modules and check if any of them have the addonObjectToLink set, if they do then
        // add the gameObject to a list
        List<GameObject> addonObjectsToLink = new List<GameObject>();
        foreach (armatureLink armatureLinkModule2 in armatureLinkModules)
        {
          if (armatureLinkModule2.addonObjectToLink != null)
          {
            addonObjectsToLink.Add(armatureLinkModule2.addonObjectToLink);
          }
        }

        // debug print the number of addonObjectsToLink
        CoreLogDebug("[Armature Link] addonObjectsToLink.Count: " + addonObjectsToLink.Count);

        // debug print the current addonObjectToLink
        CoreLogDebug(
          "[Armature Link] armatureLinkModule.addonObjectToLink: " + armatureLinkModule.addonObjectToLink.name
        );

        // remove the current addonObjectToLink from the addonObjectsToLink list (no point in checking against itself)
        addonObjectsToLink.Remove(armatureLinkModule.addonObjectToLink);

        // debug print all the addonObjectsToLink in one block
        StringBuilder addonObjectsToLinkStringBuilder = new StringBuilder();
        foreach (GameObject o in addonObjectsToLink)
        {
          addonObjectsToLinkStringBuilder.Append(o.name + "\n");
        }
        CoreLogDebug("[Armature Link] other addonObjectsToLink:\n" + addonObjectsToLinkStringBuilder.ToString());

        // check if the addonObjectsToLink from the module we are currently processing is a child of any of the other,
        // in the addonObjectsToLink in the list, if so stop processing this
        foreach (GameObject o in addonObjectsToLink)
        {
          if (armatureLinkModule.addonObjectToLink.transform.IsChildOf(o.transform))
          {
            // log a Error to the console
            CoreLogError(
              "addonObjectToLink '"
                + armatureLinkModule.addonObjectToLink.name
                + "' is a child of another addonObjectToLink '"
                + o.name
                + "', this wil cause issues, skipping this module"
            );
            return;
          }
        }
      }

      // check if armatureLinkModule.addonObjectToLink is null, if it is then return, as this a required field
      if (armatureLinkModule.addonObjectToLink == null)
      {
        if (armatureLinkModuleCount == 1)
        {
          // only bother logging a critical error if there is only one armatureLink module, as if there are more than
          // one then the other modules may be able to handle the linking (cascaded linking)
          // log a critical error to the console
          CoreLogError("addonObjectToLink is null, this is a required field");
        }
        return;
      }
      else
      {
        // log the addonObjectToLink to the console
        CoreLog("addonObjectToLink: " + armatureLinkModule.addonObjectToLink.name);
      }

      // access the CVRAvatar component on the targetAvatar
      CVRAvatar avatar = targetAvatar.GetComponent<CVRAvatar>();

      // check if the avatar exists
      if (avatar != null)
      {
        // we have the avatar, and it is valid,

        // list of all the skinned mesh renderers under the DSUObject
        SkinnedMeshRenderer[] skinnedMeshRenderers = DSUObject.GetComponentsInChildren<SkinnedMeshRenderer>(true);

        // if we get one or more skinned mesh renderers then we need mesh rebind mode if in auto mode
        bool autoFlowModeMeshRebind = CheckIfChildrenHaveSkinnedMeshRenderers(DSUObject);

        // debug print the skinnedMeshRenderers in one block
        StringBuilder skinnedMeshRenderersStringBuilder = new StringBuilder();
        foreach (SkinnedMeshRenderer skinnedMeshRenderer in skinnedMeshRenderers)
        {
          skinnedMeshRenderersStringBuilder.Append(skinnedMeshRenderer.name + "\n");
        }
        CoreLogDebug("[ArmatureLink] skinnedMeshRenderers:\n" + skinnedMeshRenderersStringBuilder.ToString());

        switch (armatureLinkModule.addonLinkMode)
        {
          case CVRFuryModuleLinker.linkMode.MeshRebind:
            // Handle MeshRebind case
            // this needs to compare the avatar's armature to the armature linked to skinned mesh renderers in/under
            // the DSUObject, and then merge the too armatures together adding in any missing bones, then rebind the
            // skinned mesh renderers to the new armature
            // note this needs to start at the bone specified in the armatureBoneToLinkTo (this being a unity standard
            // bone name) and put the two armatures together from there

            performMeshRebind(avatar, targetAvatar, DSUObject, DSUNumber, armatureLinkModule);
            break;
          case CVRFuryModuleLinker.linkMode.MergeAsChildren:
            // Deprecated, but kept for redirecting to MeshRebind
            // Handle MergeAsChildren case
            // redirect to the same as MeshRebind
            performMeshRebind(avatar, targetAvatar, DSUObject, DSUNumber, armatureLinkModule);
            break;
          case CVRFuryModuleLinker.linkMode.ParentConstraint:
            // Deprecated, but kept for redirecting to MeshRebind
            // Handle ParentConstraint case
            // redirect to the same as MeshRebind
            performMeshRebind(avatar, targetAvatar, DSUObject, DSUNumber, armatureLinkModule);
            break;
          case CVRFuryModuleLinker.linkMode.ReparentRoot:
            // Handle ReparentRoot case
            // this needs to move the addonObjectToLink to be a child of the armatureBoneToLinkTo while keeping the
            // object's position and rotation relative to the bone
            performReparentRoot(avatar, targetAvatar, DSUObject, DSUNumber, armatureLinkModule);
            break;
          case CVRFuryModuleLinker.linkMode.Auto:
            // Handle Auto case
            // this needs to check if the DSUObject has any skinned mesh renderers, if it does then it should use
            // MeshRebind, if it doesn't then it should use ReparentRoot
            CoreLog(
              "[ArmatureLink] Auto mode active, detected flow: "
                + (autoFlowModeMeshRebind ? "MeshRebind" : "ReparentRoot")
            );
            CoreLogDebug("[ArmatureLink] number of skinned mesh renderers: " + skinnedMeshRenderers.Length);

            if (autoFlowModeMeshRebind)
            {
              performMeshRebind(avatar, targetAvatar, DSUObject, DSUNumber, armatureLinkModule);
            }
            else
            {
              performReparentRoot(avatar, targetAvatar, DSUObject, DSUNumber, armatureLinkModule);
            }
            break;
          default:
            // Handle unexpected case
            // log a critical error to the console (should be impossible to reach this point)
            CoreLogCritical(
              "Unexpected module.addonLinkMode: "
                + armatureLinkModule.addonLinkMode
                + " this should not happen, please report this to the developer"
            );
            break;
        }
      }
    }

    private void performMeshRebind(
      CVRAvatar avatar,
      GameObject targetAvatar,
      GameObject DSUObject,
      int DSUNumber,
      armatureLink armatureLinkModule
    )
    {
      // Implementation for performMeshRebind
      // console print to say this function is being called
      CoreLog("performMeshRebind() called");

      // call function to add the CVRFuryGameObjectInfoTag to the DSUObject + children
      AddCVRFuryGameObjectInfoTagToAddon(DSUObject, DSUNumber);

      // get the path to the avatar
      string avatarPath = GetGameObjectPath(avatar.gameObject);

      // debug print the avatarPath
      CoreLogDebug("[ArmatureLink][MeshRebind] avatarPath: " + avatarPath);

      // get the current path of the addonObjectToLink and store it
      string addonObjectToLinkPath = GetGameObjectPath(armatureLinkModule.addonObjectToLink);

      // debug print the addonObjectToLinkPath
      CoreLogDebug("[ArmatureLink][MeshRebind] addonObjectToLinkPath: " + addonObjectToLinkPath);

      // get the new path of the addonObjectToLink and store it
      string newAddonObjectToLinkPath = GetGameObjectPath(armatureLinkModule.addonObjectToLink);

      // debug print the newAddonObjectToLinkPath
      CoreLogDebug("[ArmatureLink][MeshRebind] newAddonObjectToLinkPath: " + newAddonObjectToLinkPath);

      // ok this is mesh rebind mode, so first we need to figure out what sub object is the root of the addon armature
      // so check if there are any skinned mesh renderers components on the DSUObject's children
      // if there are then we need to merge the armatures together

      // list of all the skinned mesh renderers under the DSUObject
      SkinnedMeshRenderer[] skinnedMeshRenderersPerDSU;

      // list of game objects that the skinned mesh renderers are on
      List<GameObject> skinnedMeshRendererGameObjects = new List<GameObject>();

      // check if there are any skinned mesh renderers on the DSUObject's children
      if (CheckIfChildrenHaveSkinnedMeshRenderers(DSUObject))
      {
        // get all the skinned mesh renderers under the DSUObject
        skinnedMeshRenderersPerDSU = DSUObject.GetComponentsInChildren<SkinnedMeshRenderer>(true);

        // debug print the skinnedMeshRenderersPerDSU in one block
        StringBuilder skinnedMeshRenderersPerDSUStringBuilder = new StringBuilder();
        foreach (SkinnedMeshRenderer skinnedMeshRenderer in skinnedMeshRenderersPerDSU)
        {
          skinnedMeshRenderersPerDSUStringBuilder.Append(skinnedMeshRenderer.name + "\n");
        }
        CoreLogDebug(
          "[ArmatureLink] skinnedMeshRenderersPerDSU:\n" + skinnedMeshRenderersPerDSUStringBuilder.ToString()
        );

        // get the gameObjects that the skinned mesh renderers are on

        foreach (SkinnedMeshRenderer skinnedMeshRenderer in skinnedMeshRenderersPerDSU)
        {
          skinnedMeshRendererGameObjects.Add(skinnedMeshRenderer.gameObject);
        }

        // debug print the skinnedMeshRendererGameObjects in one block
        StringBuilder skinnedMeshRendererGameObjectsStringBuilder = new StringBuilder();
        foreach (GameObject skinnedMeshRendererGameObject in skinnedMeshRendererGameObjects)
        {
          skinnedMeshRendererGameObjectsStringBuilder.Append(skinnedMeshRendererGameObject.name + "\n");
        }
        CoreLogDebug(
          "[ArmatureLink] skinnedMeshRendererGameObjects:\n" + skinnedMeshRendererGameObjectsStringBuilder.ToString()
        );
      }
      else
      {
        // if there are no skinned mesh renderers on the DSUObject's children, then we don't need mesh rebind
        CoreLogCritical("No skinned mesh renderers found on DSUObject's children, mesh rebind not possible");
        return;
      }

      // get the gameobject of the AddonObjectToLink
      GameObject addonObjectToLink = armatureLinkModule.addonObjectToLink;

      // finding the root of the armature
      // Start with the addonObjectToLink
      Transform current = addonObjectToLink.transform;

      // Walk up the hierarchy until we reach the top
      while (current.parent != null && current.parent != DSUObject.transform)
      {
        current = current.parent;
      }

      // current is now the root GameObject of the armature, so now we can use that for exclusion purposes
      GameObject armatureRoot = current.gameObject;

      //bool to check if there are any animations to rebind
      bool animationFilesFound = true;

      // only do this if there are any animations to rebind (check if the folder/files exist first)
      // path for folder test
      string anim_folder_to_check =
        Constants.ASSETS_MANAGED_FOLDER_GENERATED + avatar.name + "/temp_items/DSU-" + DSUNumber + "/";

      // check if the folder exists
      if (!Directory.Exists(anim_folder_to_check))
      {
        // log as a debug to the console
        CoreLogDebug("No animation files found to rebind");
        animationFilesFound = false;
      }
      else
      {
        // only check if there are any animation files if the folder exists

        // check if there are any animation files in that folder (.anim extension)
        if (animationFilesFound)
        {
          // get the animation files in the folder
          string[] animFiles = Directory.GetFiles(anim_folder_to_check, "*.anim");

          // check if there are any animation files in the folder
          if (animFiles.Length == 0)
          {
            // log as a debug to the console
            CoreLogDebug("No animation files found to rebind");
            animationFilesFound = false;
          }
        }
      }

      // now all animations will have been made assuming the base is the same object that has the Animator component
      // but now we are adding it to an avatar, so we need to adjust the paths of the animations to match the new
      // hierarchy

      // first we need a list of all the objects directly under the object that the animator is on, but that do not
      // include the armatureRoot object
      List<GameObject> objectsToRebind = new List<GameObject>();
      foreach (Transform child in DSUObject.transform)
      {
        if (child.gameObject != armatureRoot)
        {
          objectsToRebind.Add(child.gameObject);
        }
      }

      // get the current path of the object that the animator is on under the avatar
      string animatorObjectPath = GetGameObjectPath(DSUObject);

      // now we need to make a rewrite dictionary to store the old paths and the new paths
      Dictionary<string, string> pathRewrite = new Dictionary<string, string>();

      // for each of the objects to rebind, we need to get the current path and store it in the pathRewrite
      // then we need to prefix that path with the animatorObjectPath and store that as the new path
      foreach (GameObject obj in objectsToRebind)
      {
        // get the current path of the object relative to the animatorObjectPath
        string currentPath = GetGameObjectPath(obj);
        // remove the animatorObjectPath from the start of the currentPath
        currentPath = currentPath.Replace(animatorObjectPath, "");
        // the above line will leave a leading `/` so remove it
        if (currentPath.StartsWith("/"))
        {
          currentPath = currentPath.Substring(1);
        }
        //this should now be the path relative to the animatorObjectPath, which should match up to the animator provided
        // with the prefab to be linked

        // get the object's path relative to the avatar
        string objectPath = GetGameObjectPath(obj);
        // remove the avatarPath from the start of the objectPath
        objectPath = objectPath.Replace(avatarPath, "");
        // remove the starting `/` from the objectPath if it exists
        if (objectPath.StartsWith("/"))
        {
          objectPath = objectPath.Substring(1);
        }

        // store the currentPath and the new path in the pathRewrite
        pathRewrite[currentPath] = objectPath;
      }

      // debug print all the pathRewrite entries in one go
      StringBuilder pathRewriteDebug = new StringBuilder();
      foreach (KeyValuePair<string, string> entry in pathRewrite)
      {
        pathRewriteDebug.Append("Key: ");
        pathRewriteDebug.Append(entry.Key);
        pathRewriteDebug.Append(", Value: ");
        pathRewriteDebug.Append(entry.Value);
        pathRewriteDebug.Append("\n");
      }
      CoreLogDebug("pathRewrite:\n" + pathRewriteDebug.ToString());

      // only do this if there are any animations to rebind
      if (animationFilesFound)
      {
        // now we need to go through all the animations and update the paths
        // create a list of path pairs from the dictionary
        List<System.Tuple<string, string>> pathPairs = new List<System.Tuple<string, string>>();
        foreach (KeyValuePair<string, string> entry in pathRewrite)
        {
          // get the current path and the new path
          string currentPath = entry.Key;
          string newPath = entry.Value;

          // check if the currentPath is the same as the newPath, if it is then skip this entry
          if (currentPath == newPath)
          {
            continue;
          }

          // add the path pair to the list
          pathPairs.Add(new System.Tuple<string, string>(currentPath, newPath));
        }

        // update the animation clips
        UpdateAnimationClips(avatar.name, pathPairs, DSUNumber);

        // refresh the asset database
        AssetDatabase.Refresh();
      }

      // that should take care of the animations, for all the mesh items sitting next to the armature
      // now we need to merge the armatures together and rebind the meshes to the new armature

      // get the Animator component from the avatar
      Animator animator = avatar.GetComponent<Animator>();
      // get the HumanBodyBones enum value from the armatureBoneToLinkTo
      HumanBodyBones boneToLinkTo = armatureLinkModule.armatureBoneToLinkTo;
      // get the GameObject of the boneToLinkTo
      GameObject boneToLinkToGameObject = animator.GetBoneTransform(boneToLinkTo).gameObject;

      // now we have the target bone on the avatar, that we are going to merge this onto

      // compare the child bones of the armatureRoot to the child bones of the boneToLinkToGameObject
      // and add any missing bones to the boneToLinkToGameObject
      // this is done by checking the names of the bones and adding any that are missing

      // walk the bones of avatar's armature starting from the parent of the boneToLinkTo and compare
      // to the armatureRoot's children
      Transform[] avatarBones = boneToLinkToGameObject.GetComponentsInChildren<Transform>();
      Transform[] addonBones = armatureRoot.GetComponentsInChildren<Transform>();

      // create a list of the names of the bones in the avatar's armature
      List<string> avatarBoneNames = new List<string>();
      foreach (Transform bone in avatarBones)
      {
        avatarBoneNames.Add(bone.name);
      }

      // create a list of the names of the bones in the addon's armature
      List<BoneData> addonBoneNames = new List<BoneData>();
      foreach (Transform bone in addonBones)
      {
        addonBoneNames.Add(new BoneData { name = bone.name, parentName = bone.parent != null ? bone.parent.name : "" });
      }

      // ensure that any 'bone' in the addonBones list whose name matches that of the armatureRoot is removed
      addonBoneNames.RemoveAll(b => b.name == armatureRoot.name);

      // debug print the armatureRoot name
      CoreLogDebug("armatureRoot.name: " + armatureRoot.name);

      // debug print the addonBoneNames list after removing the armatureRoot
      StringBuilder addonBoneNamesStringBuilder2 = new StringBuilder();
      foreach (BoneData boneData in addonBoneNames)
      {
        addonBoneNamesStringBuilder2.Append("name: " + boneData.name + ", parentName: " + boneData.parentName + "\n");
      }
      CoreLogDebug("addonBoneNames after removing armatureRoot:\n" + addonBoneNamesStringBuilder2.ToString());

      // create a list of the names of the bones in the addon's armature for comparison
      List<string> addonBoneNamesList = addonBoneNames.Select(b => b.name).ToList();

      // create a list of the bones that are in the addon's armature but not in the avatar's armature
      List<string> missingBones = addonBoneNamesList.Except(avatarBoneNames).ToList();

      // create a List of bones that are on both the avatar and the addon
      //(this is so we can check for differentials in the rotation/position/scale of the bones)
      List<string> commonBones = addonBoneNamesList.Intersect(avatarBoneNames).ToList();

      // print addonBoneNames to console in one block
      StringBuilder addonBoneNamesStringBuilder = new StringBuilder();
      foreach (BoneData boneData in addonBoneNames)
      {
        addonBoneNamesStringBuilder.Append("name: " + boneData.name + ", parentName: " + boneData.parentName + "\n");
      }
      CoreLogDebug("[ArmatureLink][lookups] addonBoneNames:\n" + addonBoneNamesStringBuilder.ToString());

      // print commonBones to console in one block
      StringBuilder commonBonesStringBuilder = new StringBuilder();
      foreach (string commonBone in commonBones)
      {
        commonBonesStringBuilder.Append(commonBone + "\n");
      }
      CoreLogDebug("[ArmatureLink][lookups] commonBones:\n" + commonBonesStringBuilder.ToString());

      // bool to allow for case insensitive comparison
      bool caseInsensitiveComparisonTriggered = false;

      if (commonBones.Count == 0)
      {
        CoreLogError(
          "No common bones found between the addon's armature and the avatar's armature"
            + "\n Reattempting case insensitive comparison"
        );

        // re try the comparison with case insensitive comparison
        commonBones = addonBoneNamesList.Intersect(avatarBoneNames, System.StringComparer.OrdinalIgnoreCase).ToList();
        // same for missing bones
        missingBones = addonBoneNamesList.Except(avatarBoneNames, System.StringComparer.OrdinalIgnoreCase).ToList();

        // print commonBones to console in one block
        StringBuilder commonBonesStringBuilder2 = new StringBuilder();
        foreach (string commonBone in commonBones)
        {
          commonBonesStringBuilder2.Append(commonBone + "\n");
        }
        CoreLogDebug(
          "[ArmatureLink][lookups] commonBones post case insensitive comparison:\n"
            + commonBonesStringBuilder2.ToString()
        );

        caseInsensitiveComparisonTriggered = true;
      }

      // if there are no commonBones then log a error to the console
      if (commonBones.Count == 0)
      {
        CoreLogCritical("No common bones found between the addon's armature and the avatar's armature");

        // show popup to user
        EditorUtility.DisplayDialog(
          "Armature Link Error",
          "No common bones found between the addon's armature and the avatar's armature",
          "OK"
        );
        return;
      }

      // print missingBones to console in one block
      StringBuilder missingBonesStringBuilder = new StringBuilder();
      foreach (string missingBone in missingBones)
      {
        missingBonesStringBuilder.Append(missingBone + "\n");
      }
      CoreLogDebug("[ArmatureLink][lookups] missingBones:\n" + missingBonesStringBuilder.ToString());

      // list of bones that have been added to the avatar's armature
      List<string> addedBones = new List<string>();

      // list to store bones that have a different rotation/position/scale
      List<string> differentBones = new List<string>();

      // loop over the commonBones and check if the rotation/position/scale of the bones are different
      foreach (string commonBoneName in commonBones)
      {
        // find the bone in the addonBones list
        BoneData commonBone = addonBoneNames.Find(b => b.name == commonBoneName);

        // depending on the caseInsensitiveComparisonTriggered bool,
        // find the bone in the avatarBones list
        Transform avatarBone = caseInsensitiveComparisonTriggered
          ? avatarBones.FirstOrDefault(b => b.name.Equals(commonBoneName, System.StringComparison.OrdinalIgnoreCase))
          : avatarBones.FirstOrDefault(b => b.name == commonBoneName);

        // find the bone in the addonBones list
        Transform addonBone = addonBones.FirstOrDefault(b => b.name == commonBoneName);

        // get the addon bone's parent
        Transform addonBoneParent = addonBones.FirstOrDefault(b => b.name == commonBone.parentName);

        // add the CVRFuryNukeGameObject component to the commonBone, if it doesn't already have one
        // this is to trigger clean up surplus gameObjects that are not needed
        if (addonBone.GetComponent<CVRFuryNukeGameObject>() == null)
        {
          addonBone.gameObject.AddComponent<CVRFuryNukeGameObject>();
          // set CVRFuryNukeGameObject component nukeEnabled to true
          addonBone.GetComponent<CVRFuryNukeGameObject>().nukeEnabled = true;
        }

        // reparent the bone to it avatar counterpart
        addonBone.SetParent(avatarBone, true);

        // check if the rotation/position/scale of the bones are different
        if (
          avatarBone.rotation != addonBone.rotation
          || avatarBone.position != addonBone.position
          || avatarBone.localScale != addonBone.localScale
        )
        {
          // add the bone name to the differentBones list
          differentBones.Add(commonBoneName);
        }

        // put the addon bone back to its original parent
        addonBone.SetParent(addonBoneParent, true);
      }

      // if there are any differentBones then log a warning to the console (including the bone names)
      if (differentBones.Count > 0)
      {
        // print differentBones to console in one block
        StringBuilder differentBonesStringBuilder = new StringBuilder();
        foreach (string differentBone in differentBones)
        {
          differentBonesStringBuilder.Append(differentBone + "\n");
        }
        CoreLogError(
          "The following bones have different rotation/position/scale in the addon's armature compared to the avatar's armature:\n"
            + differentBonesStringBuilder.ToString()
        );
      }

      // get all the skinned mesh renderers under the DSUObject
      SkinnedMeshRenderer[] skinnedMeshRenderers = DSUObject.GetComponentsInChildren<SkinnedMeshRenderer>(true);

      // debug print the skinnedMeshRenderers in one block
      StringBuilder skinnedMeshRenderersStringBuilder = new StringBuilder();
      foreach (SkinnedMeshRenderer skinnedMeshRenderer in skinnedMeshRenderers)
      {
        skinnedMeshRenderersStringBuilder.Append(skinnedMeshRenderer.name + "\n");
      }
      CoreLogDebug("[ArmatureLink] skinnedMeshRenderers:\n" + skinnedMeshRenderersStringBuilder.ToString());

      // gameObject list for the added bones
      List<GameObject> addedBonesGameObjects = new List<GameObject>();

      #region Bone re-parenting
      // loop over the missingBones and reparent them into the avatar's armature, note that they must not be moved or scaled
      // from their current position, just re-parented

      // print the missingBones to the console in one block
      StringBuilder missingBonesStringBuilder2 = new StringBuilder();
      foreach (string missingBone in missingBones)
      {
        missingBonesStringBuilder2.Append(missingBone + "\n");
      }
      CoreLogDebug("[ArmatureLink][Bone re-parenting] missingBones:\n" + missingBonesStringBuilder2.ToString());

      foreach (string missingBoneName in missingBones)
      {
        // find the bone in the addonBones list
        BoneData missingBone = addonBoneNames.Find(b => b.name == missingBoneName);

        // check if the current missing bone's parent is in the addedBones list, if it is then skip this bone
        if (addedBones.Contains(missingBone.parentName))
        {
          // skipping this bone as the parent is the top of an addon leaf bone tree (or a child of one)
          // but we need to put it on the addedBones list so that the next bones down the tree can be handled
          addedBones.Add(missingBoneName);

          // find the bone in the addonBones list
          Transform boneTransform = addonBones.FirstOrDefault(b => b.name == missingBoneName);

          // add the bone to the addedBonesGameObjects list
          addedBonesGameObjects.Add(boneTransform.gameObject);

          // now continue to the next bone
          continue;
        }

        // find the parent bone in the avatarBones list, depending on the caseInsensitiveComparisonTriggered bool
        Transform parentBone = caseInsensitiveComparisonTriggered
          ? avatarBones.FirstOrDefault(
            b => b.name.Equals(missingBone.parentName, System.StringComparison.OrdinalIgnoreCase)
          )
          : avatarBones.FirstOrDefault(b => b.name == missingBone.parentName);

        // if the parentBone is null then there is an issue, log an error to the console and continue to the next bone
        if (parentBone == null)
        {
          // log as a critical error to the console, as this should not happen
          // should never get here as all leaf bone trees should have already been filtered out
          CoreLogCritical("Parent bone not found for: " + missingBoneName);
          continue;
        }

        // find the bone in the addonBones list
        Transform bone = addonBones.FirstOrDefault(b => b.name == missingBoneName);

        // reparent the bone to the parentBone
        bone.SetParent(parentBone, true);

        // add the bone name to the addedBones list
        addedBones.Add(missingBoneName);

        // add the bone to the addedBonesGameObjects list
        addedBonesGameObjects.Add(bone.gameObject);

        // debug log to console that the bone has been re-parented
        CoreLogDebug("[ArmatureLink][Bone re-parenting] Bone has been re-parented to: " + parentBone.name);
      }
      #endregion

      #region Added Bone rename
      // now all the addon bones have been re-parented to the avatar's armature, we need to rename them so duplicates
      // copies of the addon get their own copy of the bones

      // print the paths of all the addedBonesGameObjects to the console in one block
      StringBuilder addedBonesGameObjectsStringBuilder = new StringBuilder();
      foreach (GameObject addedBoneGameObject in addedBonesGameObjects)
      {
        addedBonesGameObjectsStringBuilder.Append(addedBoneGameObject.name + "\n");
      }
      CoreLogDebug(
        "[ArmatureLink][Bone Rename] addedBonesGameObjects:\n" + addedBonesGameObjectsStringBuilder.ToString()
      );

      // loop over the addedBonesGameObjects and rename them
      foreach (GameObject addedBoneGameObject in addedBonesGameObjects)
      {
        // get the bone name
        string boneName = addedBoneGameObject.name;

        // prefix the bone name with the DSUNumber
        addedBoneGameObject.name = "[CVRF_D" + DSUNumber + "]_" + boneName;

        // debug log to console that the bone has been renamed
        CoreLogDebug("Bone has been renamed to: " + addedBoneGameObject.name);

        // find the index of bone name in the addedBones list (List<string>)
        int index = addedBones.FindIndex(b => b == boneName);

        // replace the bone name in the addedBones list with the new bone name
        addedBones[index] = addedBoneGameObject.name;
      }

      #endregion


      // now all the bones have been added to the avatar's armature, we need to rebind the skinned mesh renderers
      // to the new armature at the boneToLinkTo


      #region Skinned mesh renderer rebind

      //  loop over the skinned mesh renderers and rebind them to the new armature
      foreach (SkinnedMeshRenderer skinnedMeshRendererToRebind in skinnedMeshRenderers)
      {
        // since we are potentially changeling the mesh we need to make a copy of the original mesh
        // try to get the mesh of the skinned mesh renderer
        Mesh mesh = null;
        try
        {
          mesh = skinnedMeshRendererToRebind.sharedMesh;
        }
        catch (System.Exception e)
        {
          // log as a debug to the console
          CoreLogDebug(e);
          continue;
        }
        // get name of the game object that the skinned mesh renderer is on
        string skinnedMeshRendererGameObjectName = skinnedMeshRendererToRebind.gameObject.name;

        // debug print the mesh loaded
        CoreLogDebug("[ArmatureLink] mesh loaded for: " + skinnedMeshRendererGameObjectName);

        // create a new mesh
        mesh = GenerateNewMesh(mesh, DSUNumber, avatar, skinnedMeshRendererToRebind);

        // -------------------------------------------------------------------------------------------------------------
        // this is a workaround to get the mesh to properly update/relink
        // without this the mesh will sometimes not update properly, its random and not always the case
        // the random nature of this issue makes it hard to debug, and this is the best solution found so far
        
        // mark the game object as dirty
        EditorUtility.SetDirty(skinnedMeshRendererToRebind.gameObject);

        // wait for the editor to update
        AssetDatabase.SaveAssets();
        //--------------------------------------------------------------------------------------------------------------

        // debug print the new mesh
        CoreLogDebug("[ArmatureLink] new mesh created for: " + skinnedMeshRendererGameObjectName);

        // now we are safe to rebind the skinned mesh renderer to the new armature


        // get the scale of the avatar's armature (using the target bone's scale, as that is where we start the merge)
        float avatarArmatureScale = Math.Abs(boneToLinkToGameObject.transform.lossyScale.x);

        // check if skinnedMeshRendererToRebind.bones is null, if it is then there is an issue, log an error to the console and continue to the next skinned mesh renderer
        if (skinnedMeshRendererToRebind.bones == null)
        {
          // log as a critical error to the console, as this should not happen
          CoreLogCritical(
            "[ArmatureLink][mesh rebind] Bones not found for skinned mesh renderer : "
              + skinnedMeshRendererToRebind.name
          );
        }
        else
        {
          // log as a debug to the console
          CoreLogDebug(
            "[ArmatureLink][mesh rebind] Bones found for skinned mesh renderer : " + skinnedMeshRendererToRebind.name
          );

          // get the bones of the skinned mesh renderer
          Transform[] bonesToRebind = skinnedMeshRendererToRebind.bones;

          // list the bones that are in the skinned mesh renderer in one block
          StringBuilder bonesToRebindStringBuilder = new StringBuilder();
          foreach (Transform boneToRebind in bonesToRebind)
          {
            bonesToRebindStringBuilder.Append(boneToRebind.name + "\n");
          }
          CoreLogDebug("[ArmatureLink][mesh rebind] bonesToRebind:\n" + bonesToRebindStringBuilder.ToString());

          // now we need only rebind bones that are common to the avatar and the addon (all the others
          // are already bound to the mesh so no point in messing with them) thus the 'commonBones' list
          // will be of help to filter the bones that need to be rebound (note that its just a list of names,
          // not actual bone refs)

          // create a list of bones to update from the bonesToRebind list that are in the commonBones list
          List<Transform> bonesToUpdate = new List<Transform>();

          // loop over the bonesToRebind and find the bones that are in the commonBones list
          foreach (Transform boneToRebind in bonesToRebind)
          {
            // check if the boneToRebind is in the commonBones list
            if (commonBones.Contains(boneToRebind.name))
            {
              // add the boneToRebind to the bonesToUpdate list
              bonesToUpdate.Add(boneToRebind);
            }
          }

          // print bonesToUpdate to console in one block
          StringBuilder bonesToUpdateStringBuilder = new StringBuilder();
          foreach (Transform boneToUpdate in bonesToUpdate)
          {
            bonesToUpdateStringBuilder.Append(boneToUpdate.name + "\n");
          }
          CoreLogDebug("[ArmatureLink][mesh rebind] bonesToUpdate:\n" + bonesToUpdateStringBuilder.ToString());

          // now we have the bones that need to be rebound, we need to rebind them to the new armature


          // loop over the bonesToUpdate and rebind them to the avatar's armature
          for (int i = 0; i < bonesToUpdate.Count; i++)
          {
            // new target bone
            Transform newBone;

            // find the bone in the avatarBones list
            newBone = avatarBones.FirstOrDefault(b => b.name == bonesToUpdate[i].name);

            // check if the newBone is null, if it is then we need to do a case insensitive comparison
            if (newBone == null)
            {
              // log as a debug to the console
              CoreLogDebug(
                "[ArmatureLink][mesh rebind] Bone not found for: "
                  + bonesToUpdate[i].name
                  + ", reattempting with case insensitive comparison"
              );

              // reattempt to find the bone in the avatarBones list with case insensitive comparison
              newBone = avatarBones.FirstOrDefault(
                b => b.name.Equals(bonesToUpdate[i].name, System.StringComparison.OrdinalIgnoreCase)
              );
            }

            // if the newBone is still null then there is an issue, log an error to the console and continue to the next bone
            if (newBone == null)
            {
              // log as a critical error to the console, as this should not happen
              CoreLogCritical("[ArmatureLink][mesh rebind] New bone not found for: " + bonesToUpdate[i].name);
              // show popup to user, to inform them of the issue
              EditorUtility.DisplayDialog(
                "Armature Link Error",
                "New bone not found for: " + bonesToUpdate[i].name,
                "OK"
              );

              continue;
            }

            // find the bone in skinnedMeshRendererToRebind.bones via the name
            Transform oldBone = bonesToRebind.FirstOrDefault(b => b.name == bonesToUpdate[i].name);

            // sort out the bindposes
            mesh.bindposes = Enumerable
              .Zip(skinnedMeshRendererToRebind.bones, mesh.bindposes, (a, b) => (a, b))
              .Select(boneAndBindPose =>
              {
                var bone = boneAndBindPose.a;
                var bindPose = boneAndBindPose.b;
                if (bone != oldBone)
                  return bindPose;
                return newBone.worldToLocalMatrix * oldBone.localToWorldMatrix * bindPose;
              })
              .ToArray();

            // replace the old bone in skinnedMeshRendererToRebind.bones with the new bone
            skinnedMeshRendererToRebind.bones = skinnedMeshRendererToRebind.bones
              .Select(b => b == oldBone ? newBone : b)
              .ToArray();

            // mark the mesh as dirty
            EditorUtility.SetDirty(mesh);

            // get full paths of the old and new bones
            string oldBonePath = GetGameObjectPath(oldBone.gameObject);
            string newBonePath = GetGameObjectPath(newBone.gameObject);

            // debug log to console that the bone has been rebound
            CoreLogDebug("[ArmatureLink][mesh rebind] Bone has been rebound to: " + newBone.name + " for " + mesh.name
                        + "\n Old bone path: " + oldBonePath + "\n New bone path: " + newBonePath);
          }
        }


        // get the current Root Bone of the skinned mesh renderer
        Transform rootBone = skinnedMeshRendererToRebind.rootBone;

        // if its null then there is an issue, log an error to the console
        if (rootBone == null)
        {
          // log as a critical error to the console, as this should not happen
          CoreLogCritical("[ArmatureLink][mesh rebind] Root Bone not found for: " + skinnedMeshRendererToRebind.name);
        }
        else
        {
          // find the bone in the avatarBones list
          Transform newRootBone = avatarBones.FirstOrDefault(b => b.name == rootBone.name);

          // if the newRootBone is null then check with case insensitive comparison
          if (newRootBone == null)
          {
            // log as a debug to the console
            CoreLogDebug(
              "[ArmatureLink][mesh rebind] Root Bone not found for: "
                + rootBone.name
                + ", reattempting with case insensitive comparison"
            );

            // reattempt to find the newRootBone in the avatarBones list with case insensitive comparison
            newRootBone = avatarBones.FirstOrDefault(
              b => b.name.Equals(rootBone.name, System.StringComparison.OrdinalIgnoreCase)
            );
          }

          // if the newRootBone is still null then there is an issue, log an error to the console and continue to the next skinned mesh renderer
          if (newRootBone == null)
          {
            // log as a critical error to the console, as this should not happen
            CoreLogCritical("[ArmatureLink][mesh rebind] Root Bone not found for: " + rootBone.name);
          }
          else
          {
            // set the newRootBone to the rootBone
            skinnedMeshRendererToRebind.rootBone = newRootBone;
          }
        }

        // check if the Anchor Override is set on the skinned mesh renderer, if it is then set it to the matching bone in the avatar's armature
        if (skinnedMeshRendererToRebind.probeAnchor != null)
        {
          // find the bone in the avatarBones list
          Transform anchorOverride = avatarBones.FirstOrDefault(
            b => b.name == skinnedMeshRendererToRebind.probeAnchor.name
          );

          // if the anchorOverride target is null then we need to do a case insensitive comparison
          if (anchorOverride == null)
          {
            // log as a debug to the console
            CoreLogDebug(
              "[ArmatureLink][mesh rebind] Anchor Override target not found for: "
                + skinnedMeshRendererToRebind.probeAnchor.name
                + ", reattempting with case insensitive comparison"
            );

            // reattempt to find the anchorOverride target in the avatarBones list with case insensitive comparison
            anchorOverride = avatarBones.FirstOrDefault(
              b => b.name.Equals(skinnedMeshRendererToRebind.probeAnchor.name, System.StringComparison.OrdinalIgnoreCase)
            );
          }


          // if the anchorOverride target is still null then there is an issue, log an error to the console and continue to the next skinned mesh renderer
          if (anchorOverride == null)
          {
            // log as a critical error to the console, as this should not happen
            CoreLogCritical(
              "[ArmatureLink][mesh rebind] Anchor Override target not found for: "
                + skinnedMeshRendererToRebind.probeAnchor.name
            );
            continue;
          }

          // set the anchorOverride to the anchorOverride
          skinnedMeshRendererToRebind.probeAnchor = anchorOverride;

          // debug log to console that the skinned mesh renderer has been rebound
          CoreLogDebug("[ArmatureLink][mesh rebind] Skinned mesh renderer has been rebound to: " + anchorOverride.name);
        }
        else
        {
          // bind the skinnedMeshRendererToRebind.probeAnchor to the skinnedMeshRendererToRebind.rootBone
          skinnedMeshRendererToRebind.probeAnchor = skinnedMeshRendererToRebind.rootBone.transform;

          // debug log to console that the skinned mesh renderer has been rebound
          CoreLogDebug(
            "[ArmatureLink][mesh rebind] Skinned mesh renderer probeAnchor not set and has been auto rebound to default: " + skinnedMeshRendererToRebind.rootBone.name
          );
        }

      }

      #endregion

      #region Animation rebind
      // from the addonBoneNamesList we can get the bones that are in the addon's armature
      // given that we can use that as half the information we need to rebind the animations
      // the other half is the bones that are in the avatar's armature, we can get that from the avatarBones list
      // so we can loop over the addonBoneNamesList and find the corresponding bone in the avatarBones list
      // then we can update the animation clips to match the new bone structure

      // only do this if there are any animations to rebind
      if (animationFilesFound)
      {
        // get the number of addonBoneNamesList entries
        int addonBoneNamesListCount = addonBoneNamesList.Count;

        // debug print the addonBoneNamesListCount
        CoreLogDebug("[ArmatureLink][animation rebind] addonBoneNamesListCount: " + addonBoneNamesListCount);

        // print addonBoneNamesList to console in one block
        StringBuilder addonBoneNamesListStringBuilder = new StringBuilder();
        foreach (string addonBoneName in addonBoneNamesList)
        {
          addonBoneNamesListStringBuilder.Append(addonBoneName + "\n");
        }
        CoreLogDebug(
          "[ArmatureLink][animation rebind] addonBoneNamesList:\n" + addonBoneNamesListStringBuilder.ToString()
        );

        // get the current avatar bone set (now we have added the missing bones)
        Transform[] updatedAvatarBones = boneToLinkToGameObject.GetComponentsInChildren<Transform>();

        // list of tuples to store the path of the bone in the addon's armature and the path of the bone in the avatar's armature
        List<ObjectPathPair> addonBonePaths = new List<ObjectPathPair>();

        // list to store bone names that need to be a different case on the addon armature
        List<string> addonBoneNamesDifferentCase = new List<string>();

        // loop over the addonBoneNamesList
        foreach (string addonBoneNameInput in addonBoneNamesList)
        {
          // get the addonBoneName (needs to be a separate variable as some times need to modify it later on)
          string addonBoneName = addonBoneNameInput;
          // debug print the name of the bone
          CoreLogDebug("[ArmatureLink][animation rebind] addonBoneName: " + addonBoneName);

          // check if the bone name is in the commonBones list
          if (!commonBones.Contains(addonBoneName))
          {
            // not a common bone, so need to apply the rename
            // add the prefix to the addonBoneName
            addonBoneName = "[CVRF_D" + DSUNumber + "]_" + addonBoneName;
          }
          else
          {
            // common bone, so no need to apply the rename
            // debug print that the bone is a common bone
            CoreLogDebug("[ArmatureLink][animation rebind] Common bone: " + addonBoneName);
          }

          // get the path of the bone in the avatar's armature
          string avatarBonePathBase = GetBonePath(updatedAvatarBones, addonBoneName);

          //  remove the avatarPath from the start of the avatarBonePath
          string avatarBonePath = avatarBonePathBase.Replace(avatarPath, "");

          // remove the starting `/` from the avatarBonePath if it exists
          if (avatarBonePath.StartsWith("/"))
          {
            avatarBonePath = avatarBonePath.Substring(1);
          }

          // TODO: remove this debug print
          // // debug print the path of the bone in the avatar's armature
          // CoreLogDebug("[ArmatureLink][animation rebind] avatarBonePath: " + avatarBonePath);


          // get the base path of the addon GameObject
          string addonBasePath = addonObjectToLinkPath;

          // remove the leaf from the addonBasePath
          int lastSlashIndex = addonBasePath.LastIndexOf("/");
          addonBasePath = addonBasePath.Substring(0, lastSlashIndex);

          // remove the animatorObjectPath from the start of the addonBasePath
          addonBasePath = addonBasePath.Replace(animatorObjectPath, "");

          // remove the starting `/` from the addonBasePath if it exists
          if (addonBasePath.StartsWith("/"))
          {
            addonBasePath = addonBasePath.Substring(1);
          }

          // TODO: remove this debug print
          // Debug print the boneToLinkToGameObject.name
          CoreLogDebug("[ArmatureLink][animation rebind] boneToLinkToGameObject.name: " + boneToLinkToGameObject.name);

          // Append the name of boneToLinkToGameObject to the addonBasePath
          string addonBonePath = addonBasePath + "/" + boneToLinkToGameObject.name;

          //
          int index = avatarBonePath.IndexOf(boneToLinkToGameObject.name);

          if (index != -1)
          {
            // append the addonBonePath and the avatarBonePath to the addonBonePaths list
            addonBonePath = addonBonePath + avatarBonePath.Substring(index + boneToLinkToGameObject.name.Length);

            // path to compare after replacment
            string addonBonePathToCompareAfterReplace = addonBonePath;
            // Perform a case-insensitive replacement (in case the addon bone name has a
            // different case to the avatar bone name)
            addonBonePath = RewritePathCaseInsensitive(addonBonePath, addonBoneNameInput);

            // if addonBoneNamesDifferentCase contains any elements, then we need to do a replacement for each of them
            // in turn
            foreach (string addonBoneNameDifferentCase in addonBoneNamesDifferentCase)
            {
              // Perform a case-insensitive replacement (in case the addon bone name has a
              // different case to the avatar bone name)
              addonBonePath = RewritePathCaseInsensitive(addonBonePath, addonBoneNameDifferentCase);
            }

            // if the addonBonePath has been changed by the case insensitive replacement, add the bone name to the
            // addonBoneNamesDifferentCase list
            if (addonBonePath != addonBonePathToCompareAfterReplace)
            {
              addonBoneNamesDifferentCase.Add(addonBoneNameInput);
            }

            // debug print the addonBonePath
            CoreLogDebug("[ArmatureLink][animation rebind] addonBonePath case rewrite: " + addonBonePath);
          }
          else
          {
            // really no match, this should never happen
            // log as a critical error to the console
            CoreLogCritical(
              "[ArmatureLink][animation rebind] Bone not found in avatar armature: " + boneToLinkToGameObject.name
            );
            // continue to the next bone
            continue;
            
          }

          // TODO: remove this debug print
          // // debug print the base addon path
          // CoreLogDebug("addonBonePath: " + addonBonePath);

          // remove all instances of the prefix from the addonBonePath (as we need the original path for the
          // animation rebind)
          addonBonePath = addonBonePath.Replace("[CVRF_D" + DSUNumber + "]_", "");

          // add the addonBonePath and avatarBonePath to the addonBonePaths list
          addonBonePaths.Add(
            new ObjectPathPair { addonObjectToLinkPath = addonBonePath, newAddonObjectToLinkPath = avatarBonePath }
          );
        }

        // get the number of addonBonePaths entries
        int addonBonePathsCount = addonBonePaths.Count;
        // debug print the addonBonePathsCount
        CoreLogDebug("[ArmatureLink][animation rebind] addonBonePathsCount: " + addonBonePathsCount);

        // print all the addonBonePaths to console in one block
        StringBuilder addonBonePathsStringBuilder = new StringBuilder();
        foreach (ObjectPathPair objectPathPair in addonBonePaths)
        {
          addonBonePathsStringBuilder.Append(
            "addonPath: "
              + objectPathPair.addonObjectToLinkPath
              + ", avatarPath: "
              + objectPathPair.newAddonObjectToLinkPath
              + "\n"
          );
        }
        CoreLogDebug("[ArmatureLink][animation rebind] addonBonePaths:\n" + addonBonePathsStringBuilder.ToString());

        // create a list of tuples to store the addonBoneObjectPath and the newAddonBoneObjectPath
        List<System.Tuple<string, string>> addonBonePathsTuple = addonBonePaths
          .Select(pair => new System.Tuple<string, string>(pair.addonObjectToLinkPath, pair.newAddonObjectToLinkPath))
          .ToList();

        // mass update the animation clips (multi path per save)
        UpdateAnimationClips(avatar.name, addonBonePathsTuple, DSUNumber);

        // only need to do the asset db refresh once, at the end of the loop
        AssetDatabase.Refresh();
      }
      #endregion

      #region DSU cleanup
      // now we have merged the armatures and rebound the skinned mesh renderers, we can clean up any surplus
      // gameObjects under the DSU object that are not needed

      // debug print the DSUObject is being cleaned up
      CoreLogDebug("[ArmatureLink][DSU Cleanup] Cleaning up DSUObject");

      GameObject[] DSUChildGameObjects = null;
      // try to get all the gameObjects under the DSUObject
      try
      {
        DSUChildGameObjects = DSUObject.GetComponentsInChildren<Transform>().Select(t => t.gameObject).ToArray();
      }
      catch (System.Exception e)
      {
        // log as a debug to the console
        CoreLogDebug("[ArmatureLink][DSU Cleanup] Load error");
        CoreLogDebug(e);
        return;
      }
      // debug print the that the DSUChildGameObjects have been loaded
      CoreLogDebug("[ArmatureLink][DSU Cleanup] DSUChildGameObjects loaded");

      // remove all gameObjects from the list that have the CVRFuryNukeGameObject component attached
      DSUChildGameObjects = DSUChildGameObjects
        .Where(gameObject => gameObject.GetComponent<CVRFuryNukeGameObject>() == null)
        .ToArray();

      // debug print the number of DSUChildGameObjects
      CoreLogDebug("[ArmatureLink][DSU Cleanup] DSUChildGameObjects count: " + DSUChildGameObjects.Length);

      // debug print the gameObjects in one block
      StringBuilder gameObjectsStringBuilder = new StringBuilder();
      foreach (GameObject gameObject in DSUChildGameObjects)
      {
        gameObjectsStringBuilder.Append(gameObject.name + "\n");
      }
      CoreLogDebug("[ArmatureLink][DSU Cleanup] gameObjects:\n" + gameObjectsStringBuilder.ToString());

      // loop over the DSUChildGameObjects and check if they have any components on them
      foreach (GameObject gameObject in DSUChildGameObjects)
      {
        // get the components on the gameObject
        Component[] components = gameObject.GetComponents<Component>();

        // remove all components from the list that are of type 'UnityEngine.Transform'
        components = components.Where(component => component.GetType() != typeof(Transform)).ToArray();

        // remove all components from that list that are in the Constants.CVRFURY_COMPONENTS_TO_REMOVE list
        components = components
          .Where(component => !Constants.CVRFURY_COMPONENTS_TO_REMOVE.Contains(component.GetType().ToString()))
          .ToArray();

        // remove all components from that list that are in the Constants.CVRFURY_DEP_COMPONENTS_TO_REMOVE list
        components = components
          .Where(component => !Constants.CVRFURY_DEP_COMPONENTS_TO_REMOVE.Contains(component.GetType().ToString()))
          .ToArray();

        // list the component types on the gameObject in one block, if there are any
        StringBuilder componentsStringBuilder = new StringBuilder();
        foreach (Component component in components)
        {
          componentsStringBuilder.Append(component.GetType().ToString() + "\n");
        }
        CoreLogDebug(
          "[ArmatureLink][DSU Cleanup] components in " + gameObject.name + ":\n" + componentsStringBuilder.ToString()
        );

        // if there are no components on the gameObject then destroy the gameObject
        if (components.Length == 0)
        {
          // add the CVRFuryNukeGameObject component to the commonBone, if it doesn't already have one
          // this is to trigger clean up surplus gameObjects that are not needed
          if (gameObject.GetComponent<CVRFuryNukeGameObject>() == null)
          {
            gameObject.AddComponent<CVRFuryNukeGameObject>();
            // set CVRFuryNukeGameObject component nukeEnabled to true
            gameObject.GetComponent<CVRFuryNukeGameObject>().nukeEnabled = true;
          }
          // print that the gameObject has set for removal
          CoreLog(
            "[ArmatureLink][DSU Cleanup] " + gameObject.name + " has tagged for removal as it has no useful components"
          );
        }
      }

      #endregion
    }

    private void performReparentRoot(
      CVRAvatar avatar,
      GameObject targetAvatar,
      GameObject DSUObject,
      int DSUNumber,
      armatureLink armatureLinkModule
    )
    {
      // Implementation for performReparentRoot
      // console print to say this function is being called
      CoreLog("[ArmatureLink] performReparentRoot() called");

      // call function to add the CVRFuryGameObjectInfoTag to the DSUObject + children
      AddCVRFuryGameObjectInfoTagToAddon(DSUObject, DSUNumber);

      // get the path to the avatar
      string avatarPath = GetGameObjectPath(avatar.gameObject);

      // get the current path of the addonObjectToLink and store it
      string addonObjectToLinkPath = GetGameObjectPath(armatureLinkModule.addonObjectToLink);

      // remove the avatarPath from the start of the addonObjectToLinkPath
      addonObjectToLinkPath = addonObjectToLinkPath.Replace(avatarPath, "");

      // remove the starting `/` from the addonObjectToLinkPath if it exists
      if (addonObjectToLinkPath.StartsWith("/"))
      {
        addonObjectToLinkPath = addonObjectToLinkPath.Substring(1);
      }

      // move the addonObjectToLink to be a child of the armatureBoneToLinkTo, note armatureBoneToLinkTo is of
      // type HumanBodyBones, the addonObjectToLink is of type GameObject and the addonObjectToLink should not move in
      // scene space but just be parented to the bone (this is so the user can position the object where they want it)

      // get the Animator component from the avatar
      Animator animator = avatar.GetComponent<Animator>();

      // get the HumanBodyBones enum value from the armatureBoneToLinkTo
      HumanBodyBones boneToLinkTo = armatureLinkModule.armatureBoneToLinkTo;

      // get the GameObject of the boneToLinkTo
      GameObject boneToLinkToGameObject = animator.GetBoneTransform(boneToLinkTo).gameObject;

      // add a empty GameObject to the boneToLinkToGameObject, this is for insulation purposes
      GameObject addonParent = new GameObject("CVRF_Addon_" + DSUNumber);

      // put the addonParent as a child of the boneToLinkToGameObject
      addonParent.transform.SetParent(boneToLinkToGameObject.transform, true);

      // put the addonObjectToLink as a child of the boneToLinkToGameObject
      armatureLinkModule.addonObjectToLink.transform.SetParent(boneToLinkToGameObject.transform, true);

      // copy the position/rotation/scale of the addonObjectToLink to the addonParent
      addonParent.transform.position = armatureLinkModule.addonObjectToLink.transform.position;
      addonParent.transform.rotation = armatureLinkModule.addonObjectToLink.transform.rotation;
      addonParent.transform.localScale = armatureLinkModule.addonObjectToLink.transform.localScale;

      // reparent the addonObjectToLink to the addonParent
      armatureLinkModule.addonObjectToLink.transform.SetParent(addonParent.transform, true);

      // debug log to console that the object has been re-parented
      CoreLogDebug("[ArmatureLink] Object has been re-parented to: " + boneToLinkToGameObject.name);

      // ok now to take care of any duplicates (people may want more than one of the same object), we need to
      // add a tag to the start of the object name to make it unique

      // get the name of the addonObjectToLink
      string addonObjectToLinkName = armatureLinkModule.addonObjectToLink.name;

      // new name of the addonObjectToLink
      string newAddonObjectToLinkName = "[CVRF_D" + DSUNumber + "]_" + addonObjectToLinkName;

      // prefix the name of the addonObjectToLink with the DSUNumber
      armatureLinkModule.addonObjectToLink.name = newAddonObjectToLinkName;

      // console print to say renaming is done
      CoreLog("[ArmatureLink] Renaming from " + addonObjectToLinkName + " to " + newAddonObjectToLinkName + " done");

      // get the new path of the addonObjectToLink and store it
      string newAddonObjectToLinkPath = GetGameObjectPath(armatureLinkModule.addonObjectToLink);

      // remove the avatarPath from the start of the newAddonObjectToLinkPath
      newAddonObjectToLinkPath = newAddonObjectToLinkPath.Replace(avatarPath, "");

      // remove the starting `/` from the newAddonObjectToLinkPath if it exists
      if (newAddonObjectToLinkPath.StartsWith("/"))
      {
        newAddonObjectToLinkPath = newAddonObjectToLinkPath.Substring(1);
      }

      // debug log to console the new path of the addonObjectToLink
      CoreLogDebug("[ArmatureLink] newAddonObjectToLinkPath: " + newAddonObjectToLinkPath);

      // ok, so now we have the new path of the addonObjectToLink, that is the base for re-writing the animation clips
      // note the animations packaged with the addon will be expected to start from that as a root

      // get the DSU component from the DSUObject
      CVRFuryDataStorageUnit DSUComponent = DSUObject.GetComponent<CVRFuryDataStorageUnit>();

      // check if the modules of the DSUComponent  and see if there is a fullControllerModule type module present
      if (DSUComponent.modules.modules.Any(m => m.ModuleType == "fullControllerModule"))
      {
        // of so there is a fullControllerModule type module present,

        // get the fullControllerModule from the DSUComponent
        fullControllerModule controllerModule =
          DSUComponent.modules.modules.FirstOrDefault(m => m.ModuleType == "fullControllerModule")
          as fullControllerModule;

        // check if the fullControllerModule is null, if it is then there is an issue, log an error to the console and return
        if (controllerModule == null)
        {
          CoreLogError("fullControllerModule is null, cannot rebind animations");
          return;
        }

        // get the controllers from the fullControllerModule
        List<RuntimeAnimatorController> controllers = controllerModule.controllers;

        // check if the controllers is null or empty, if it is then looks like there are no animations to rebind,
        // log a warning to the console and return
        if (controllers == null || controllers.Count == 0)
        {
          // log as a warning to the console
          CoreLog("[Warning] controllers is null or empty, no animations to rebind");
          return;
        }

        // at this point there is at least one controller in the controllers list, so there should be animations to
        // rebind. so w need to check if there is a folder for the animations, if there is not then there is an issue,
        // log an error to the console and return

        // the folder path for the animations
        string animationsFolderPath =
          Constants.ASSETS_MANAGED_FOLDER_GENERATED + avatar.name + "/temp_items/DSU-" + DSUNumber + "/";

        // debug print the animationsFolderPath
        CoreLogDebug("[ArmatureLink] animationsFolderPath: " + animationsFolderPath);

        // get a list of all files in the animationsFolderPath
        string[] animationFiles = Directory.GetFiles(animationsFolderPath);

        // remove all files that are not animation animationFiles from the animationFiles list
        animationFiles = animationFiles.Where(f => f.EndsWith(".anim")).ToArray();

        // remove all animationFiles that have '_clip_gen_pre_' in the name from the animationFiles list
        animationFiles = animationFiles.Where(f => !f.Contains("_clip_gen_pre_")).ToArray();

        // check if the animationFiles is null or empty, if it is then there is an issue, log an error to the console and return
        if (animationFiles == null || animationFiles.Length == 0)
        {
          // log as an error to the console
          CoreLogError("animationFiles is null or empty, no animations to rebind");
          return;
        }

        // debug print the list of animationFiles to console in one block
        StringBuilder animationFilesStringBuilder = new StringBuilder();
        foreach (string animationFile in animationFiles)
        {
          animationFilesStringBuilder.Append(animationFile + "\n");
        }
        CoreLogDebug("[ArmatureLink] animationFiles:\n" + animationFilesStringBuilder.ToString());

        // at this point there is at least one animation file in the animationFiles array, so there should be animations
        // to rebind. so we need to loop over them and re-write the paths

        // ObjectPathPair list to store the addonObjectToLinkPath and the newAddonObjectToLinkPath
        List<ObjectPathPair> objectPathPairs = new List<ObjectPathPair>();

        // loop over the animationFiles and rebind the paths
        foreach (string animationFile in animationFiles)
        {
          // print to console that the animation file is being processed
          CoreLog("[ArmatureLink] Processing animation file: " + animationFile);

          // load the animation clip from the animationFile
          AnimationClip clip = AssetDatabase.LoadAssetAtPath<AnimationClip>(animationFile);

          // get all the paths in the clip
          EditorCurveBinding[] curveBindings = AnimationUtility.GetCurveBindings(clip);
          EditorCurveBinding[] objectReferenceCurveBindings = AnimationUtility.GetObjectReferenceCurveBindings(clip);

          // merge curveBindings and objectReferenceCurveBindings
          EditorCurveBinding[] allCurveBindings = curveBindings.Concat(objectReferenceCurveBindings).ToArray();

          // overwrite the curveBindings with the allCurveBindings (so we can use the same loop for both)
          curveBindings = allCurveBindings;

          // debug print all the curveBindings to console in one block
          StringBuilder curveBindingsStringBuilder = new StringBuilder();
          foreach (EditorCurveBinding curveBinding in curveBindings)
          {
            curveBindingsStringBuilder.Append(
              "path: "
                + curveBinding.path
                + ", propertyName: "
                + curveBinding.propertyName
                + ", type: "
                + curveBinding.type
                + "\n\n"
            );
          }
          CoreLogDebug("[ArmatureLink] curveBindings:\n\n" + curveBindingsStringBuilder.ToString());

          // var for the addonObjectToLinkNameForPathRewrites, as needs to be modified
          string addonObjectToLinkNameForPathRewrites = addonObjectToLinkName;

          // only do this bit if we have an imported module
          // (the converter adds the suffix .CVRFury by default to differentiate it from the original prefab)
          if (controllerModule.importedFromVRCFury)
          {
            // remove the '.CVRFury' from the addonObjectToLinkNameForPathRewrites if it exists
            if (addonObjectToLinkNameForPathRewrites.EndsWith(".CVRFury"))
            {
              CoreLogDebug(
                "[ArmatureLink] addonObjectToLinkNameForPathRewrites pre-cleanup: "
                  + addonObjectToLinkNameForPathRewrites
              );
              // remove the '.CVRFury' from the end of addonObjectToLinkNameForPathRewrites
              addonObjectToLinkNameForPathRewrites = addonObjectToLinkNameForPathRewrites.Substring(
                0,
                addonObjectToLinkNameForPathRewrites.Length - ".CVRFury".Length
              );
              CoreLogDebug(
                "[ArmatureLink] addonObjectToLinkNameForPathRewrites post-cleanup: "
                  + addonObjectToLinkNameForPathRewrites
              );
            }
          }

          // get the CVRFuryAvatarInfoUnit component from the targetAvatar GameObject (it will always be there as it is
          // it is added by the pre-run tasks)
          CVRFuryAvatarInfoUnit avatarInfoUnit = targetAvatar.GetComponent<CVRFuryAvatarInfoUnit>();

          // get the avatarArmaturePaths list from the CVRFuryAvatarInfoUnit
          List<string> avatarArmaturePaths = avatarInfoUnit.avatarArmaturePaths;

          // check how many entries are in the avatarArmaturePaths list
          int avatarArmaturePathsCount = avatarArmaturePaths.Count;

          // if there are one or more we need to remove them from the curveBindings
          // this is so that we don't impact animations the prefab maker intended to impact the core armature
          if (avatarArmaturePathsCount > 0)
          {
            // debug print the avatarArmaturePathsCount
            CoreLogDebug("[ArmatureLink] avatarArmaturePathsCount: " + avatarArmaturePathsCount);

            // debug print the avatarArmaturePaths to console in one block
            StringBuilder avatarArmaturePathsStringBuilder = new StringBuilder();
            foreach (string avatarArmaturePath in avatarArmaturePaths)
            {
              avatarArmaturePathsStringBuilder.Append(avatarArmaturePath + "\n");
            }
            CoreLogDebug("[ArmatureLink] avatarArmaturePaths:\n" + avatarArmaturePathsStringBuilder.ToString());

            // debug print the curveBindings to the console in one block
            StringBuilder curveBindingsStringBuilder2 = new StringBuilder();
            foreach (EditorCurveBinding curveBinding in curveBindings)
            {
              curveBindingsStringBuilder2.Append(
                "path: "
                  + curveBinding.path
                  + ", propertyName: "
                  + curveBinding.propertyName
                  + ", type: "
                  + curveBinding.type
                  + "\n\n"
              );
            }
            CoreLogDebug("[ArmatureLink] curveBindings pre-filtering:\n\n" + curveBindingsStringBuilder2.ToString());

            // remove any curveBindings that have the avatarArmaturePaths in the path
            curveBindings = curveBindings.Where(cb => !avatarArmaturePaths.Contains(cb.path)).ToArray();

            // debug print the curveBindings to the console in one block
            StringBuilder curveBindingsStringBuilder3 = new StringBuilder();
            foreach (EditorCurveBinding curveBinding in curveBindings)
            {
              curveBindingsStringBuilder3.Append(
                "path: "
                  + curveBinding.path
                  + ", propertyName: "
                  + curveBinding.propertyName
                  + ", type: "
                  + curveBinding.type
                  + "\n\n"
              );
            }
            CoreLogDebug("[ArmatureLink] curveBindings post-filtering:\n\n" + curveBindingsStringBuilder3.ToString());
          }

          // debug print the count of the curveBindings
          CoreLogDebug("[ArmatureLink] curveBindings count: " + curveBindings.Length);

          // prefix the path of the curveBindings with the newAddonObjectToLinkPath
          foreach (EditorCurveBinding curveBinding in curveBindings)
          {
            // get the path of the curveBinding
            string path = curveBinding.path;

            // if path is empty then there is an issue, log an error to the console and continue to the next curveBinding
            if (string.IsNullOrEmpty(path))
            {
              // log as an error to the console
              CoreLogError("[ArmatureLink] Path is empty for curveBinding: " + curveBinding.propertyName);
              continue;
            }

            string trailingPath;

            // check if there is a '/' in the path
            if (!path.Contains("/"))
            {
              // no slash in the path, thus no trailing path
              trailingPath = "";
            }
            else
            {
              // remove the first part of the path up to the first '/'
              int firstSlashIndex = path.IndexOf("/");
              trailingPath = path.Substring(firstSlashIndex);
            }

            // debug print the path, newAddonObjectToLinkPath and trailingPath
            CoreLogDebug(
              "[ArmatureLink] path: "
                + path
                + "\n newAddonObjectToLinkPath: "
                + newAddonObjectToLinkPath
                + "\n trailingPath: "
                + trailingPath
            );

            objectPathPairs.Add(
              new ObjectPathPair
              {
                addonObjectToLinkPath = path,
                newAddonObjectToLinkPath = newAddonObjectToLinkPath + trailingPath
              }
            );
          }

          // debug log to console that the animation file has been re-written
          CoreLog("[ArmatureLink] Animation paths updates from  '" + animationFile + "' stored");
        }

        // deduplicate the objectPathPairs list
        objectPathPairs = objectPathPairs.Distinct().ToList();

        // print all the objectPathPairs to console in one block
        StringBuilder objectPathPairsStringBuilder = new StringBuilder();
        foreach (ObjectPathPair objectPathPair in objectPathPairs)
        {
          objectPathPairsStringBuilder.Append(
            "addonPath: "
              + objectPathPair.addonObjectToLinkPath
              + ",\n avatarPath: "
              + objectPathPair.newAddonObjectToLinkPath
              + "\n\n"
          );
        }
        CoreLogDebug("[ArmatureLink] objectPathPairs:\n" + objectPathPairsStringBuilder.ToString());

        // create a list of tuples to store the addonObjectToLinkPath and the newAddonObjectToLinkPath
        List<System.Tuple<string, string>> objectPathPairsTuple = objectPathPairs
          .Select(pair => new System.Tuple<string, string>(pair.addonObjectToLinkPath, pair.newAddonObjectToLinkPath))
          .ToList();

        // mass update the animation clips (multi path per save)
        UpdateAnimationClips(avatar.name, objectPathPairsTuple, DSUNumber);

        // log that the animation clips have been updated
        CoreLog("[ArmatureLink] Animation clips updated");

        // at this point all the animation files have been re-written, so we need to save/refresh the asset database

        // save the asset database
        AssetDatabase.SaveAssets();
        // update the asset database
        AssetDatabase.Refresh();
      }
    }

    // -----------------------------------------------------------------------------------------------------------------
    #region Helper Functions/structs

    public Mesh GenerateNewMesh(Mesh mesh, int DSUNumber, CVRAvatar avatar, SkinnedMeshRenderer skinnedMeshRenderer)
    {
      // ensure that the folder to put the mesh in exists (we can't rely on it being there)
      if (!Directory.Exists(Constants.ASSETS_MANAGED_FOLDER_GENERATED + avatar.name + "/temp_items"))
      {
        Directory.CreateDirectory(Constants.ASSETS_MANAGED_FOLDER_GENERATED + avatar.name + "/temp_items");
        // log as a debug to the console
        CoreLogDebug("[ArmatureLink] Created temp_items folder");
      }
      else
      {
        // log as a debug to the console
        CoreLogDebug("[ArmatureLink] temp_items folder already exists");
      }

      // print that mesh is being copied
      CoreLogDebug("Copying mesh");

      // copy the mesh to a new file
      string meshPath =
        Constants.ASSETS_MANAGED_FOLDER_GENERATED
        + avatar.name
        + "/temp_items/"
        + skinnedMeshRenderer.name
        + "_DSU-"
        + DSUNumber
        + ".asset";
      AssetDatabase.CreateAsset(Object.Instantiate(mesh), meshPath);
      CoreLogDebug("[ArmatureLink] Mesh copied to: " + meshPath);

      // // Force Unity to import the asset immediately, ensuring it's ready for use
      // AssetDatabase.ImportAsset(meshPath, ImportAssetOptions.ForceUpdate);

      // ok so now we have a copy of the mesh, we need to set the skinned mesh renderer to use the new mesh
      skinnedMeshRenderer.sharedMesh = AssetDatabase.LoadAssetAtPath<Mesh>(meshPath);

      // get the new mesh
      return skinnedMeshRenderer.sharedMesh;
    }

    public string RewritePathCaseInsensitive( string inputPath, string inputToReplace)
    {
      // Split the path into segments
      string[] segments = inputPath.Split('/');

      // Iterate through the segments and replace the matching segment
      for (int i = 0; i < segments.Length; i++)
      {
          // Check if the current segment matches inputToReplace case-insensitively
          if (string.Equals(segments[i], inputToReplace, System.StringComparison.OrdinalIgnoreCase))
          {
              // Replace the segment
              segments[i] = inputToReplace;
          }
      }

      // Reconstruct the path
      return string.Join("/", segments);

    }


    public string GetBonePath(Transform[] avatarBones, string boneName)
    {
      // Implementation for GetBonePath
      // console print to say this function is being called
      CoreLog("GetBonePath() called");

      // get the bone from the avatarBones array
      Transform bone = avatarBones.FirstOrDefault(b => b.name == boneName);

      // if the bone is null then there we need to do a case insensitive search
      if (bone == null)
      {
        // get the bone from the avatarBones array using a case insensitive search
        bone = avatarBones.FirstOrDefault(b => b.name.Equals(boneName, System.StringComparison.OrdinalIgnoreCase));
      }

      // if the bone is still null then there is an issue, log an error to the console and return an empty string
      if (bone == null)
      {
        // log as an error to the console
        CoreLogError("Bone not found: " + boneName);
        return "";
      }

      // get the path of the bone
      string path = GetGameObjectPath(bone.gameObject);

      // return the path of the bone
      return path;
    }

    public void AddCVRFuryGameObjectInfoTagToAddon(GameObject DSUObject, int DSUNumber)
    {
      // check if the DSUObject has a CVRFuryDataStorageUnit component, if it does not then return
      if (DSUObject.GetComponent<CVRFuryDataStorageUnit>() == null)
      {
        CoreLogError("DSUObject does not have a CVRFuryDataStorageUnit component, cannot add CVRFuryGameObjectInfoTag");
        return;
      }

      // get the prefabName from the DSU component of the DSUObject
      string prefabName = DSUObject.GetComponent<CVRFuryDataStorageUnit>().prefabName;

      // check if the prefabName is null or empty, if it is then return
      if (string.IsNullOrEmpty(prefabName))
      {
        CoreLogError("prefabName is null or empty, cannot add CVRFuryGameObjectInfoTag");
        return;
      }

      // debug log to console the prefabName
      CoreLogDebug("prefabName: " + prefabName);

      // get the list of all children of the DSUObject
      List<GameObject> children = DSUObject.GetAllChildGameObjects();

      // loop over the children of the DSUObject and add the CVRFuryGameObjectInfoTag component to each child
      foreach (GameObject child in children)
      {
        // check if the child has a CVRFuryGameObjectInfoTag component, if it does not then add it
        if (child.GetComponent<CVRFuryGameObjectInfoTag>() == null)
        {
          child.AddComponent<CVRFuryGameObjectInfoTag>();
        }

        // get the CVRFuryGameObjectInfoTag component from the child
        CVRFuryGameObjectInfoTag CVRFuryGameObjectInfoTag = child.GetComponent<CVRFuryGameObjectInfoTag>();

        // set the sourcePrefabName on the CVRFuryGameObjectInfoTag component
        CVRFuryGameObjectInfoTag.sourcePrefabName = prefabName;

        // set the DSUNumber on the CVRFuryGameObjectInfoTag component
        CVRFuryGameObjectInfoTag.sourceDSUNumber = DSUNumber;
      }

      // add the CVRFuryGameObjectInfoTag component to the DSUObject
      if (DSUObject.GetComponent<CVRFuryGameObjectInfoTag>() == null)
      {
        DSUObject.AddComponent<CVRFuryGameObjectInfoTag>();
      }
      // set the sourcePrefabName on the CVRFuryGameObjectInfoTag component
      DSUObject.GetComponent<CVRFuryGameObjectInfoTag>().sourcePrefabName = prefabName;

      // set the DSUNumber on the CVRFuryGameObjectInfoTag component
      DSUObject.GetComponent<CVRFuryGameObjectInfoTag>().sourceDSUNumber = DSUNumber;

      // debug log that all the CVRFuryGameObjectInfoTag components have been added
      CoreLogDebug("All CVRFuryGameObjectInfoTag components added");
    }

    public void UpdateAnimationClips(string avatarName, List<System.Tuple<string, string>> pathPairs, int DSUNumber)
    {
      string animationClipsFolder =
        Constants.ASSETS_MANAGED_FOLDER_GENERATED + avatarName + "/temp_items/DSU-" + DSUNumber + "/";

      if (!Directory.Exists(animationClipsFolder))
      {
        CoreLogError("Animation clips folder does not exist: " + animationClipsFolder);
        return;
      }

      foreach (var pathPair in pathPairs)
      {
        if (string.IsNullOrEmpty(pathPair.Item1) || string.IsNullOrEmpty(pathPair.Item2))
        {
          CoreLogError("One of the paths in the pair is null or empty");
          return;
        }
      }

      CoreLogDebug("Animation clips folder: " + animationClipsFolder);

      foreach (string animationClipPath in Directory.GetFiles(animationClipsFolder))
      {
        if (!File.Exists(animationClipPath))
        {
          CoreLogCritical("File does not exist: " + animationClipPath);
          continue;
        }

        if (!animationClipPath.EndsWith(".anim"))
        {
          // don't process non animation files
          continue;
        }

        if (animationClipPath.Contains("_clip_gen_pre_"))
        {
          // don't process 'pre' files
          continue;
        }

        AnimationClip clip = AssetDatabase.LoadAssetAtPath<AnimationClip>(animationClipPath);
        EditorCurveBinding[] curveBindings = AnimationUtility.GetCurveBindings(clip);

        foreach (EditorCurveBinding curveBinding in curveBindings)
        {
          foreach (var pathPair in pathPairs)
          {
            if (curveBinding.path == pathPair.Item1)
            {
              EditorCurveBinding newCurveBinding = new EditorCurveBinding
              {
                path = pathPair.Item2,
                type = curveBinding.type,
                propertyName = curveBinding.propertyName
              };

              AnimationCurve curve = AnimationUtility.GetEditorCurve(clip, curveBinding);
              AnimationUtility.SetEditorCurve(clip, curveBinding, null);
              AnimationUtility.SetEditorCurve(clip, newCurveBinding, curve);
            }
          }
        }
        // debug log to console that the animation file has been re-written for the curveBindings
        CoreLogDebug(
          "[ArmatureLink] Animation paths updates from  '" + animationClipPath + "' re-written for the curveBindings"
        );

        // Code for handling 'PPtrCurves'
        EditorCurveBinding[] objectReferenceCurveBindings = AnimationUtility.GetObjectReferenceCurveBindings(clip);

        foreach (EditorCurveBinding objectReferenceCurveBinding in objectReferenceCurveBindings)
        {
          foreach (var pathPair in pathPairs)
          {
            if (objectReferenceCurveBinding.path == pathPair.Item1)
            {
              EditorCurveBinding newObjectReferenceCurveBinding = new EditorCurveBinding
              {
                path = pathPair.Item2,
                type = objectReferenceCurveBinding.type,
                propertyName = objectReferenceCurveBinding.propertyName
              };

              ObjectReferenceKeyframe[] curve = AnimationUtility.GetObjectReferenceCurve(
                clip,
                objectReferenceCurveBinding
              );
              AnimationUtility.SetObjectReferenceCurve(clip, objectReferenceCurveBinding, null);
              AnimationUtility.SetObjectReferenceCurve(clip, newObjectReferenceCurveBinding, curve);
            }
          }
        }

        // debug log to console that the animation file has been re-written for the objectReferenceCurveBindings
        CoreLogDebug(
          "[ArmatureLink] Animation paths updates from  '"
            + animationClipPath
            + "' re-written for the objectReferenceCurveBindings"
        );

        AssetDatabase.SaveAssets();
        EditorUtility.SetDirty(clip);
      }
    }

    public void UpdateAnimationClips(
      string avatarName,
      string addonObjectToLinkPath,
      string newAddonObjectToLinkPath,
      int DSUNumber
    )
    {
      string animationClipsFolder =
        Constants.ASSETS_MANAGED_FOLDER_GENERATED + avatarName + "/temp_items/DSU-" + DSUNumber + "/";

      if (!Directory.Exists(animationClipsFolder))
      {
        CoreLogError("Animation clips folder does not exist: " + animationClipsFolder);
        return;
      }

      // if the addonObjectToLinkPath and newAddonObjectToLinkPath are the same then return
      if (addonObjectToLinkPath == newAddonObjectToLinkPath)
      {
        CoreLogDebug("No animation rebind needed as Object has not moved");
        return;
      }

      // if addonObjectToLinkPath is null or empty then return
      if (string.IsNullOrEmpty(addonObjectToLinkPath))
      {
        CoreLogError("addonObjectToLinkPath is null or empty");
        return;
      }

      // if newAddonObjectToLinkPath is null or empty then return
      if (string.IsNullOrEmpty(newAddonObjectToLinkPath))
      {
        CoreLogError("newAddonObjectToLinkPath is null or empty");
        return;
      }

      CoreLogDebug("Animation clips folder: " + animationClipsFolder);

      foreach (string animationClipPath in Directory.GetFiles(animationClipsFolder))
      {
        if (!File.Exists(animationClipPath))
        {
          CoreLogCritical("File does not exist: " + animationClipPath);
          continue;
        }

        if (!animationClipPath.EndsWith(".anim"))
        {
          // don't process non animation files
          continue;
        }

        if (animationClipPath.Contains("_clip_gen_pre_"))
        {
          // don't process 'pre' files
          continue;
        }

        CoreLogDebug("addonObjectToLinkPath: " + addonObjectToLinkPath);
        CoreLogDebug("newAddonObjectToLinkPath: " + newAddonObjectToLinkPath);

        AnimationClip clip = AssetDatabase.LoadAssetAtPath<AnimationClip>(animationClipPath);
        EditorCurveBinding[] curveBindings = AnimationUtility.GetCurveBindings(clip);

        foreach (EditorCurveBinding curveBinding in curveBindings)
        {
          CoreLogDebug("Current curveBinding.path: " + curveBinding.path);

          if (curveBinding.path == addonObjectToLinkPath)
          {
            EditorCurveBinding newCurveBinding = new EditorCurveBinding
            {
              path = newAddonObjectToLinkPath,
              type = curveBinding.type,
              propertyName = curveBinding.propertyName
            };

            AnimationCurve curve = AnimationUtility.GetEditorCurve(clip, curveBinding);
            AnimationUtility.SetEditorCurve(clip, curveBinding, null);
            AnimationUtility.SetEditorCurve(clip, newCurveBinding, curve);
          }
        }

        // Code for handling 'PPtrCurves'
        EditorCurveBinding[] objectReferenceCurveBindings = AnimationUtility.GetObjectReferenceCurveBindings(clip);

        foreach (EditorCurveBinding objectReferenceCurveBinding in objectReferenceCurveBindings)
        {
          CoreLogDebug("Current objectReferenceCurveBinding.path: " + objectReferenceCurveBinding.path);

          if (objectReferenceCurveBinding.path == addonObjectToLinkPath)
          {
            EditorCurveBinding newObjectReferenceCurveBinding = new EditorCurveBinding
            {
              path = newAddonObjectToLinkPath,
              type = objectReferenceCurveBinding.type,
              propertyName = objectReferenceCurveBinding.propertyName
            };

            ObjectReferenceKeyframe[] curve = AnimationUtility.GetObjectReferenceCurve(
              clip,
              objectReferenceCurveBinding
            );
            AnimationUtility.SetObjectReferenceCurve(clip, objectReferenceCurveBinding, null);
            AnimationUtility.SetObjectReferenceCurve(clip, newObjectReferenceCurveBinding, curve);
          }
        }

        AssetDatabase.SaveAssets();
        EditorUtility.SetDirty(clip);
      }
    }

    // struct to store bone data (name and parent name)
    public struct BoneData
    {
      public string name;
      public string parentName;
    }

    // struct to store object path pairs
    public struct ObjectPathPair
    {
      public string addonObjectToLinkPath;
      public string newAddonObjectToLinkPath;
    }

    #endregion
  }
}
// #endif
