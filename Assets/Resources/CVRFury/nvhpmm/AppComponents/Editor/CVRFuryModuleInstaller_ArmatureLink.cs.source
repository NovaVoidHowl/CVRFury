// { "version": "0.0.146" , "canInstall": true , "optional": true , "defineSymbolSuffix": "_MI_AL", dependencies: []}
// #if UNITY_EDITOR && CVR_CCK_EXISTS

using Math = System.Math;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System.IO;
using UnityEditor;
using UnityEditor.Animations;
using UnityEditor.UIElements;
using UnityEngine;
using UnityEngine.UIElements;
using UnityEngine.SceneManagement;
using uk.novavoidhowl.dev.cvrfury.runtime;
using ABI.CCK.Scripts.Editor;
using ABI.CCK.Scripts;
using ABI.CCK.Components;
using Constants = uk.novavoidhowl.dev.cvrfury.packagecore.Constants;
using static uk.novavoidhowl.dev.cvrfury.packagecore.CoreUtils;
using static uk.novavoidhowl.dev.cvrfury.deployable.ReportBuilderSupport;
using static uk.novavoidhowl.dev.cvrfury.supporting_classes.editor.Animation;
using static uk.novavoidhowl.dev.cvrfury.supporting_classes.runtime.General;

// temp using for testing
using System.Text;

/// <summary>
/// armatureLink Module
/// this is handles binding objects to the armature of the avatar and merging addon armatures
/// </summary>

namespace uk.novavoidhowl.dev.cvrfury.deployable
{
  public class armatureLinkModuleProcessor : IModuleProcessor
  {
    public void ProcessModule(CVRFuryModule module, GameObject targetAvatar, int DSUNumber, GameObject DSUObject)
    {
      // Implementation for armatureLinkModuleProcessor
      // console print to say this function is being called
      CoreLog("armatureLinkModuleProcessor.ProcessModule() called");

      // log the module's moduleType to the console
      CoreLog("module.ModuleType: " + module.ModuleType);

      // access the CVRAvatar component on the targetAvatar
      CVRAvatar avatar = targetAvatar.GetComponent<CVRAvatar>();

      // check if the avatar exists
      if (avatar != null)
      {
        // we have the avatar, and it is valid,

        // bool to say if we have need mesh rebind mode
        bool needsMeshRebind = true;

        // check if there are any animator components on the DSUObject or any of its children
        if (DSUObject.GetComponent<Animator>() == null && DSUObject.GetComponentsInChildren<Animator>().Length == 0)
        {
          // if there are no animator components on the DSUObject or any of its children, then we don't need mesh rebind
          needsMeshRebind = false;
        }

        // cast the module to a armatureLinkModule
        armatureLink armatureLinkModule = (armatureLink)module;

        switch (armatureLinkModule.addonLinkMode)
        {
          case CVRFuryModuleLinker.linkMode.MeshRebind:
            // Handle MeshRebind case
            // this needs to compare the avatar's armature to the armature linked to skinned mesh renderers in/under
            // the DSUObject, and then merge the too armatures together adding in any missing bones, then rebind the
            // skinned mesh renderers to the new armature
            // note this needs to start at the bone specified in the armatureBoneToLinkTo (this being a unity standard
            // bone name) and put the two armatures together from there

            performMeshRebind(avatar, DSUObject, DSUNumber, armatureLinkModule);
            break;
          case CVRFuryModuleLinker.linkMode.MergeAsChildren:
            // Deprecated, but kept for redirecting to MeshRebind
            // Handle MergeAsChildren case
            // redirect to the same as MeshRebind
            performMeshRebind(avatar, DSUObject, DSUNumber, armatureLinkModule);
            break;
          case CVRFuryModuleLinker.linkMode.ParentConstraint:
            // Deprecated, but kept for redirecting to MeshRebind
            // Handle ParentConstraint case
            // redirect to the same as MeshRebind
            performMeshRebind(avatar, DSUObject, DSUNumber, armatureLinkModule);
            break;
          case CVRFuryModuleLinker.linkMode.ReparentRoot:
            // Handle ReparentRoot case
            // this needs to move the addonObjectToLink to be a child of the armatureBoneToLinkTo while keeping the
            // object's position and rotation relative to the bone
            performReparentRoot(avatar, DSUObject, DSUNumber, armatureLinkModule);
            break;
          case CVRFuryModuleLinker.linkMode.Auto:
            // Handle Auto case
            // this needs to check if the DSUObject has any skinned mesh renderers, if it does then it should use
            // MeshRebind, if it doesn't then it should use ReparentRoot
            if (needsMeshRebind)
            {
              performMeshRebind(avatar, DSUObject, DSUNumber, armatureLinkModule);
            }
            else
            {
              performReparentRoot(avatar, DSUObject, DSUNumber, armatureLinkModule);
            }
            break;
          default:
            // Handle unexpected case
            // log a critical error to the console (should be impossible to reach this point)
            CoreLogCritical(
              "Unexpected module.addonLinkMode: "
                + armatureLinkModule.addonLinkMode
                + " this should not happen, please report this to the developer"
            );
            break;
        }
      }
    }

    private void performMeshRebind(
      CVRAvatar avatar,
      GameObject DSUObject,
      int DSUNumber,
      armatureLink armatureLinkModule
    )
    {
      // Implementation for performMeshRebind
      // console print to say this function is being called
      CoreLog("performMeshRebind() called");

      // call function to add the CVRFuryGameObjectInfoTag to the DSUObject + children
      AddCVRFuryGameObjectInfoTagToAddon(DSUObject, DSUNumber);

      // get the path to the avatar
      string avatarPath = GetGameObjectPath(avatar.gameObject);

      // get the current path of the addonObjectToLink and store it
      string addonObjectToLinkPath = GetGameObjectPath(armatureLinkModule.addonObjectToLink);

      // get the new path of the addonObjectToLink and store it
      string newAddonObjectToLinkPath = GetGameObjectPath(armatureLinkModule.addonObjectToLink);

      // ok this is mesh rebind mode, so first we need to figure out what sub object is the root of the addon armature
      // so check if there are any animator components on the DSUObject or any of its children
      if (DSUObject.GetComponent<Animator>() == null && DSUObject.GetComponentsInChildren<Animator>().Length == 0)
      {
        // if there are no animator components on the DSUObject or any of its children, then we can't do mesh rebind
        // log an error to the console and return
        CoreLogError("No Animator component found on DSUObject or any of its children, cannot perform mesh rebind");
        return;
      }

      // check if there is not an animator component on the DSUObject and if so abort
      if (DSUObject.GetComponent<Animator>() == null)
      {
        // log an error to the console and return
        CoreLogError("No Animator component found on DSUObject, cannot perform mesh rebind");
        return;
      }

      // at this point we know there is an animator component on the DSUObject, so check if it has a avatar assigned
      if (DSUObject.GetComponent<Animator>().avatar == null)
      {
        // log an error to the console and return
        CoreLogError("No Avatar assigned to Animator component on DSUObject, cannot perform mesh rebind");
        return;
      }

      // get the gameobject of the AddonObjectToLink
      GameObject addonObjectToLink = armatureLinkModule.addonObjectToLink;

      // finding the root of the armature
      // Start with the addonObjectToLink
      Transform current = addonObjectToLink.transform;

      // Walk up the hierarchy until we reach the top
      while (current.parent != null && current.parent != DSUObject.transform)
      {
        current = current.parent;
      }

      // current is now the root GameObject of the armature, so now we can use that for exclusion purposes
      GameObject armatureRoot = current.gameObject;

      // now all animations will have been made assuming the base is the same object that has the Animator component
      // but now we are adding it to an avatar, so we need to adjust the paths of the animations to match the new
      // hierarchy

      // first we need a list of all the objects directly under the object that the animator is on, but that do not
      // include the armatureRoot object
      List<GameObject> objectsToRebind = new List<GameObject>();
      foreach (Transform child in DSUObject.transform)
      {
        if (child.gameObject != armatureRoot)
        {
          objectsToRebind.Add(child.gameObject);
        }
      }

      // get the current path of the object that the animator is on under the avatar
      string animatorObjectPath = GetGameObjectPath(DSUObject);

      // now we need to make a rewrite dictionary to store the old paths and the new paths
      Dictionary<string, string> pathRewrite = new Dictionary<string, string>();

      // for each of the objects to rebind, we need to get the current path and store it in the pathRewrite
      // then we need to prefix that path with the animatorObjectPath and store that as the new path
      foreach (GameObject obj in objectsToRebind)
      {
        // get the current path of the object relative to the animatorObjectPath
        string currentPath = GetGameObjectPath(obj);
        // remove the animatorObjectPath from the start of the currentPath
        currentPath = currentPath.Replace(animatorObjectPath, "");
        // the above line will leave a leading `/` so remove it
        if (currentPath.StartsWith("/"))
        {
          currentPath = currentPath.Substring(1);
        }
        //this should now be the path relative to the animatorObjectPath, which should match up to the animator provided
        // with the prefab to be linked

        // get the object's path relative to the avatar
        string objectPath = GetGameObjectPath(obj);
        // remove the avatarPath from the start of the objectPath
        objectPath = objectPath.Replace(avatarPath, "");
        // remove the starting `/` from the objectPath if it exists
        if (objectPath.StartsWith("/"))
        {
          objectPath = objectPath.Substring(1);
        }

        // store the currentPath and the new path in the pathRewrite
        pathRewrite[currentPath] = objectPath;
      }

      // debug print all the pathRewrite entries in one go
      StringBuilder pathRewriteDebug = new StringBuilder();
      foreach (KeyValuePair<string, string> entry in pathRewrite)
      {
        pathRewriteDebug.Append("Key: ");
        pathRewriteDebug.Append(entry.Key);
        pathRewriteDebug.Append(", Value: ");
        pathRewriteDebug.Append(entry.Value);
        pathRewriteDebug.Append("\n");
      }
      CoreLogDebug("pathRewrite:\n" + pathRewriteDebug.ToString());

      // now we need to go through all the animations and update the paths
      // create a list of path pairs from the dictionary
      List<System.Tuple<string, string>> pathPairs = new List<System.Tuple<string, string>>();
      foreach (KeyValuePair<string, string> entry in pathRewrite)
      {
        // get the current path and the new path
        string currentPath = entry.Key;
        string newPath = entry.Value;

        // check if the currentPath is the same as the newPath, if it is then skip this entry
        if (currentPath == newPath)
        {
          continue;
        }

        // add the path pair to the list
        pathPairs.Add(new System.Tuple<string, string>(currentPath, newPath));
      }

      // update the animation clips
      UpdateAnimationClips(avatar.name, pathPairs, DSUNumber);

      // refresh the asset database
      AssetDatabase.Refresh();

      // that should take care of the animations, for all the mesh items sitting next to the armature
      // now we need to merge the armatures together and rebind the meshes to the new armature

      // get the Animator component from the avatar
      Animator animator = avatar.GetComponent<Animator>();
      // get the HumanBodyBones enum value from the armatureBoneToLinkTo
      HumanBodyBones boneToLinkTo = armatureLinkModule.armatureBoneToLinkTo;
      // get the GameObject of the boneToLinkTo
      GameObject boneToLinkToGameObject = animator.GetBoneTransform(boneToLinkTo).gameObject;

      // now we have the target bone on the avatar, that we are going to merge this onto

      // compare the child bones of the armatureRoot to the child bones of the boneToLinkToGameObject
      // and add any missing bones to the boneToLinkToGameObject
      // this is done by checking the names of the bones and adding any that are missing

      // walk the bones of avatar's armature starting from the parent of the boneToLinkTo and compare
      // to the armatureRoot's children
      Transform[] avatarBones = boneToLinkToGameObject.GetComponentsInChildren<Transform>();
      Transform[] addonBones = armatureRoot.GetComponentsInChildren<Transform>();

      // create a list of the names of the bones in the avatar's armature
      List<string> avatarBoneNames = new List<string>();
      foreach (Transform bone in avatarBones)
      {
        avatarBoneNames.Add(bone.name);
      }

      // create a list of the names of the bones in the addon's armature
      List<BoneData> addonBoneNames = new List<BoneData>();
      foreach (Transform bone in addonBones)
      {
        addonBoneNames.Add(new BoneData { name = bone.name, parentName = bone.parent != null ? bone.parent.name : "" });
      }

      // ensure that any 'bone' in the addonBones list whose name matches that of the armatureRoot is removed
      addonBoneNames.RemoveAll(b => b.name == armatureRoot.name);

      // debug print the armatureRoot name
      CoreLogDebug("armatureRoot.name: " + armatureRoot.name);

      // debug print the addonBoneNames list after removing the armatureRoot
      StringBuilder addonBoneNamesStringBuilder2 = new StringBuilder();
      foreach (BoneData boneData in addonBoneNames)
      {
        addonBoneNamesStringBuilder2.Append("name: " + boneData.name + ", parentName: " + boneData.parentName + "\n");
      }
      CoreLogDebug("addonBoneNames after removing armatureRoot:\n" + addonBoneNamesStringBuilder2.ToString());

      // create a list of the names of the bones in the addon's armature for comparison
      List<string> addonBoneNamesList = addonBoneNames.Select(b => b.name).ToList();

      // create a list of the bones that are in the addon's armature but not in the avatar's armature
      List<string> missingBones = addonBoneNamesList.Except(avatarBoneNames).ToList();

      // create a List of bones that are on both the avatar and the addon
      //(this is so we can check for differentials in the rotation/position/scale of the bones)
      List<string> commonBones = addonBoneNamesList.Intersect(avatarBoneNames).ToList();

      // print addonBoneNames to console in one block
      StringBuilder addonBoneNamesStringBuilder = new StringBuilder();
      foreach (BoneData boneData in addonBoneNames)
      {
        addonBoneNamesStringBuilder.Append("name: " + boneData.name + ", parentName: " + boneData.parentName + "\n");
      }
      CoreLogDebug("[ArmatureLink][lookups] addonBoneNames:\n" + addonBoneNamesStringBuilder.ToString());

      // print commonBones to console in one block
      StringBuilder commonBonesStringBuilder = new StringBuilder();
      foreach (string commonBone in commonBones)
      {
        commonBonesStringBuilder.Append(commonBone + "\n");
      }
      CoreLogDebug("[ArmatureLink][lookups] commonBones:\n" + commonBonesStringBuilder.ToString());

      // print missingBones to console in one block
      StringBuilder missingBonesStringBuilder = new StringBuilder();
      foreach (string missingBone in missingBones)
      {
        missingBonesStringBuilder.Append(missingBone + "\n");
      }
      CoreLogDebug("[ArmatureLink][lookups] missingBones:\n" + missingBonesStringBuilder.ToString());

      // list of bones that have been added to the avatar's armature
      List<string> addedBones = new List<string>();

      // list to store bones that have a different rotation/position/scale
      List<string> differentBones = new List<string>();

      // loop over the commonBones and check if the rotation/position/scale of the bones are different
      foreach (string commonBoneName in commonBones)
      {
        // find the bone in the addonBones list
        BoneData commonBone = addonBoneNames.Find(b => b.name == commonBoneName);

        // find the bone in the avatarBones list
        Transform avatarBone = avatarBones.FirstOrDefault(b => b.name == commonBoneName);

        // find the bone in the addonBones list
        Transform addonBone = addonBones.FirstOrDefault(b => b.name == commonBoneName);

        // check if the rotation/position/scale of the bones are different
        if (
          avatarBone.rotation != addonBone.rotation
          || avatarBone.position != addonBone.position
          || avatarBone.localScale != addonBone.localScale
        )
        {
          // add the bone name to the differentBones list
          differentBones.Add(commonBoneName);
        }
      }

      // if there are any differentBones then log a warning to the console (including the bone names)
      if (differentBones.Count > 0)
      {
        // print differentBones to console in one block
        StringBuilder differentBonesStringBuilder = new StringBuilder();
        foreach (string differentBone in differentBones)
        {
          differentBonesStringBuilder.Append(differentBone + "\n");
        }
        CoreLogError(
          "The following bones have different rotation/position/scale in the addon's armature compared to the avatar's armature:\n"
            + differentBonesStringBuilder.ToString()
        );
      }

      // get a list of vertices that are affected by the bones that are different
      // this is so we can warn the user that the vertices will not move as expected
      // this is done by getting the skinned mesh renderers that are affected by the bones that are different
      // and then getting the vertices that are affected by those skinned mesh renderers

      // get all the skinned mesh renderers under the DSUObject
      SkinnedMeshRenderer[] skinnedMeshRenderers = DSUObject.GetComponentsInChildren<SkinnedMeshRenderer>(true);

      // debug print the skinnedMeshRenderers in one block
      StringBuilder skinnedMeshRenderersStringBuilder = new StringBuilder();
      foreach (SkinnedMeshRenderer skinnedMeshRenderer in skinnedMeshRenderers)
      {
        skinnedMeshRenderersStringBuilder.Append(skinnedMeshRenderer.name + "\n");
      }
      CoreLogDebug("[ArmatureLink] skinnedMeshRenderers:\n" + skinnedMeshRenderersStringBuilder.ToString());

      // TODO: still need to finish implementing this section
      #region Mesh re-processing
      // loop over the skinned mesh renderers and get the vertices that are affected by the bones that are different
      foreach (SkinnedMeshRenderer skinnedMeshRenderer in skinnedMeshRenderers)
      {
        // get the bones of the skinned mesh renderer
        Transform[] bones = skinnedMeshRenderer.bones;

        // create a new list of bones to store the bones that are different
        List<Transform> differentBonesTransforms = new List<Transform>();

        // loop over the bones and find the bones that are different
        foreach (Transform bone in bones)
        {
          // find the bone in the differentBones list
          if (differentBones.Contains(bone.name))
          {
            // add the bone to the differentBonesTransforms list
            differentBonesTransforms.Add(bone);
          }
        }

        // get the mesh of the skinned mesh renderer
        Mesh mesh = skinnedMeshRenderer.sharedMesh;

        // get the vertices of the mesh
        Vector3[] vertices = mesh.vertices;

        // create a new list of vertices to store the vertices that are affected by the bones that are different
        List<Vector3> affectedVertices = new List<Vector3>();

        // loop over the vertices and find the vertices that are affected by the bones that are different
        foreach (Vector3 vertex in vertices)
        {
          // get the bone weights of the vertex
          BoneWeight[] boneWeights = mesh.boneWeights;

          // loop over the bone weights and find the bone weights that are affected by the bones that are different
          foreach (BoneWeight boneWeight in boneWeights)
          {
            // check if the bone weight is affected by the bones that are different
            if (
              differentBonesTransforms.Contains(bones[boneWeight.boneIndex0])
              || differentBonesTransforms.Contains(bones[boneWeight.boneIndex1])
              || differentBonesTransforms.Contains(bones[boneWeight.boneIndex2])
              || differentBonesTransforms.Contains(bones[boneWeight.boneIndex3])
            )
            {
              // add the vertex to the affectedVertices list
              affectedVertices.Add(vertex);
            }
          }
        }

        // if there are any affectedVertices then log a warning to the console (including the number of vertices)
        if (affectedVertices.Count > 0)
        {
          CoreLogError(
            "The following vertices are affected by the bones that have different rotation/position/scale "
              + " in the addon's armature compared to the avatar's armature, these vertices will not"
              + " move as expected: "
              + affectedVertices.Count
          );

          // ok so this is bad news. for some reason or the bones don't match up, and are going to impact the vertices
          // need to make a copy of the mesh at this point so we can try to counteract the issue

          // copy the mesh to a new file
          string meshPath =
            Constants.ASSETS_MANAGED_FOLDER_GENERATED
            + avatar.name
            + "/temp_items/"
            + skinnedMeshRenderer.name
            + "_DSU-"
            + DSUNumber
            + ".asset";
          AssetDatabase.CreateAsset(Object.Instantiate(mesh), meshPath);
          CoreLogDebug("Mesh copied to: " + meshPath);

          // ok so now we have a copy of the mesh, we need to set the skinned mesh renderer to use the new mesh
          skinnedMeshRenderer.sharedMesh = AssetDatabase.LoadAssetAtPath<Mesh>(meshPath);

          // get the new mesh
          mesh = skinnedMeshRenderer.sharedMesh;

          // now we need to update the new mesh to counteract the vertices displacement/rotation/scale

          //     // temp affectedVertices list so we can write to it (as the original is readonly while iterating)
          //     List<Vector3> affectedVerticesTemp = new List<Vector3>(affectedVertices);

          //     // get count of affectedVertices
          //     int affectedVerticesCount = affectedVertices.Count;

          //     // print to console that we are starting to process the affectedVertices
          //     CoreLog("Processing " + affectedVerticesCount + " affected vertices");

          //     // counter to keep track of how many affectedVertices have been processed
          //     int affectedVerticesProcessed = 0;

          //     // if the affectedVerticesCount is 0 then there is nothing to do, log a debug to the console and continue
          //     // to the next skinned mesh renderer
          //     if (affectedVerticesCount == 0)
          //     {
          //       // log as a debug to the console
          //       CoreLogDebug("No affected vertices found for skinned mesh renderer");
          //       continue;
          //     }

          //     // loop over the affectedVertices and counteract the displacement/rotation/scale
          //     foreach (Vector3 vertex in affectedVertices)
          //     {
          //       #region Counteract displacement/rotation/scale
          //       // counteract the displacement/rotation/scale

          //       // // console print to say we are processing x of y affected vertices
          //       // CoreLogDebug("Processing affected vertex " + affectedVerticesProcessed + " of " + affectedVerticesCount);

          //       // // get the bones linked to the vertex
          //       // List<Transform> bonesLinkedToVertex = new List<Transform>();

          //       // // get the bone weights of the vertex
          //       // BoneWeight[] boneWeights = mesh.boneWeights;

          //       // // get the count of boneweights
          //       // int boneWeightsCount = boneWeights.Length;

          //       // // if the boneWeightsCount is 0 then there is an issue, log an error to the console and continue to the next vertex
          //       // if (boneWeightsCount == 0 || boneWeights == null)
          //       // {
          //       //   // log as a critical error to the console, as this should not happen
          //       //   CoreLogCritical("No bone weights found for vertex");
          //       //   continue;
          //       // }

          //       // // print to console that we are starting to process the bone weights
          //       // CoreLog("Processing " + boneWeightsCount + " bone weights for vertex");

          //       // // counter to keep track of how many boneweights have been processed
          //       // int boneWeightsProcessed = 0;

          //       // // loop over the bone weights and find the bones linked to the vertex
          //       // foreach (BoneWeight boneWeight in boneWeights)
          //       // {
          //       //   // check if the bone weight is linked to the vertex
          //       //   if (vertex == vertices[boneWeight.boneIndex0] ||
          //       //       vertex == vertices[boneWeight.boneIndex1] ||
          //       //       vertex == vertices[boneWeight.boneIndex2] ||
          //       //       vertex == vertices[boneWeight.boneIndex3])
          //       //   {
          //       //     // add the bone to the bonesLinkedToVertex list
          //       //     bonesLinkedToVertex.Add(bones[boneWeight.boneIndex0]);
          //       //     bonesLinkedToVertex.Add(bones[boneWeight.boneIndex1]);
          //       //     bonesLinkedToVertex.Add(bones[boneWeight.boneIndex2]);
          //       //     bonesLinkedToVertex.Add(bones[boneWeight.boneIndex3]);
          //       //   }

          //       //   // increment the boneWeightsProcessed counter
          //       //   boneWeightsProcessed++;

          //       //   // print a debug message to the console if the boneWeightsProcessed showing progress
          //       //   if (boneWeightsProcessed % 1000 == 0)
          //       //   {
          //       //     CoreLogDebug("boneWeightsProcessed: " + boneWeightsProcessed + " of " + boneWeightsCount);
          //       //   }
          //       // }

          // //       // that will be the current set of bones that are linked to the vertex, ie the ones from the addon armature
          // //       // that are different to the avatar armature

          // //       // now we need to find the bones in the avatar armature that are linked to the vertex

          // //       // get the bones in the avatar armature that are linked to the vertex
          // //       List<Transform> avatarBonesLinkedToVertex = new List<Transform>();

          // //       // loop over the bonesLinkedToVertex and find the bones in the avatar armature that are linked to the vertex
          // //       foreach (Transform boneLinkedToVertex in bonesLinkedToVertex)
          // //       {
          // //         // find the bone in the avatarBones list
          // //         Transform avatarBoneLinkedToVertex = avatarBones.FirstOrDefault(b => b.name == boneLinkedToVertex.name);

          // //         // if the avatarBoneLinkedToVertex is null then there is an issue, log an error to the console and continue to the next bone
          // //         if (avatarBoneLinkedToVertex == null)
          // //         {
          // //           // log as a critical error to the console, as this should not happen
          // //           CoreLogCritical("Avatar bone not found for: " + boneLinkedToVertex.name);
          // //           continue;
          // //         }

          // //         // add the avatarBoneLinkedToVertex to the avatarBonesLinkedToVertex list
          // //         avatarBonesLinkedToVertex.Add(avatarBoneLinkedToVertex);
          // //       }

          // //       // now we have the bones in the avatar armature that are linked to the vertex, we need to counteract the
          // //       // displacement/rotation/scale issue

          // //       // counteract the displacement/rotation/scale issue
          // //       // this is done by getting the transform differences between the bones in the addon armature and the bones
          // //       // in the avatar armature, then applying those differences to the vertex

          // //       // get the transform differences between the bones in the addon armature and the bones in the avatar armature
          // //       // this is done by getting the position/rotation/scale differences between the bones in the addon armature
          // //       // and the bones in the avatar armature
          // //       // then applying those differences to the vertex

          // //       // loop over the avatarBonesLinkedToVertex and find the transform differences between the bones in the addon
          // //       // armature and the bones in the avatar armature
          // //       foreach (Transform avatarBoneLinkedToVertex in avatarBonesLinkedToVertex)
          // //       {
          // //         // find the bone in the addonBones list
          // //         Transform boneLinkedToVertex = bonesLinkedToVertex.FirstOrDefault(b => b.name == avatarBoneLinkedToVertex.name);

          // //         // if the boneLinkedToVertex is null then there is an issue, log an error to the console and continue to the next bone
          // //         if (boneLinkedToVertex == null)
          // //         {
          // //           // log as a critical error to the console, as this should not happen
          // //           CoreLogCritical("Bone not found for: " + avatarBoneLinkedToVertex.name);
          // //           continue;
          // //         }

          // //         // get the position/rotation/scale differences between the bones in the addon armature and the bones in the avatar armature
          // //         Vector3 positionDifference = boneLinkedToVertex.position - avatarBoneLinkedToVertex.position;
          // //         Quaternion rotationDifference = boneLinkedToVertex.rotation * Quaternion.Inverse(avatarBoneLinkedToVertex.rotation);
          // //         Vector3 scaleDifference = boneLinkedToVertex.localScale - avatarBoneLinkedToVertex.localScale;

          // //         // duplicate the vertex so we can apply the differences to it (as the original is readonly while iterating)
          // //         Vector3 vertexCopy = vertex;

          // //         // apply the position/rotation/scale differences to the vertex
          // //         vertexCopy += positionDifference;
          // //         vertexCopy = rotationDifference * vertexCopy;
          // //         vertexCopy += scaleDifference;

          // //         // add the vertex to the affectedVerticesTemp list
          // //         affectedVerticesTemp.Add(vertexCopy);

          // //       }

          //     // increment the affectedVerticesProcessed counter
          //     affectedVerticesProcessed++;
          //     #endregion
          //     }


          //     // now write the affectedVerticesTemp back to the affectedVertices
          //     affectedVertices = new List<Vector3>(affectedVerticesTemp);

          //     // then we need to update the new mesh with the new vertices
          //     mesh.vertices = affectedVertices.ToArray();
          //     mesh.RecalculateNormals();
          //     mesh.RecalculateBounds();
          //     mesh.RecalculateTangents();

          //     // now mark the mesh as dirty
          //     EditorUtility.SetDirty(mesh);

          //     // then refresh and save the asset database
          //     AssetDatabase.Refresh();
          //     AssetDatabase.SaveAssets();
        }
      }
      #endregion


      // gameObject list for the added bones
      List<GameObject> addedBonesGameObjects = new List<GameObject>();

      #region Bone re-parenting
      // loop over the missingBones and reparent them into the avatar's armature, note that they must not be moved or scaled
      // from their current position, just re-parented

      // print the missingBones to the console in one block
      StringBuilder missingBonesStringBuilder2 = new StringBuilder();
      foreach (string missingBone in missingBones)
      {
        missingBonesStringBuilder2.Append(missingBone + "\n");
      }
      CoreLogDebug("[ArmatureLink][Bone re-parenting] missingBones:\n" + missingBonesStringBuilder2.ToString());

      foreach (string missingBoneName in missingBones)
      {
        // find the bone in the addonBones list
        BoneData missingBone = addonBoneNames.Find(b => b.name == missingBoneName);

        // check if the current missing bone's parent is in the addedBones list, if it is then skip this bone
        if (addedBones.Contains(missingBone.parentName))
        {
          // skipping this bone as the parent is the top of an addon leaf bone tree (or a child of one)
          // but we need to put it on the addedBones list so that the next bones down the tree can be handled
          addedBones.Add(missingBoneName);

          // find the bone in the addonBones list
          Transform boneTransform = addonBones.FirstOrDefault(b => b.name == missingBoneName);

          // add the bone to the addedBonesGameObjects list
          addedBonesGameObjects.Add(boneTransform.gameObject);

          // now continue to the next bone
          continue;
        }

        // find the parent bone in the avatarBones list
        Transform parentBone = avatarBones.FirstOrDefault(b => b.name == missingBone.parentName);

        // if the parentBone is null then there is an issue, log an error to the console and continue to the next bone
        if (parentBone == null)
        {
          // log as a critical error to the console, as this should not happen
          // should never get here as all leaf bone trees should have already been filtered out
          CoreLogCritical("Parent bone not found for: " + missingBoneName);
          continue;
        }

        // find the bone in the addonBones list
        Transform bone = addonBones.FirstOrDefault(b => b.name == missingBoneName);

        // reparent the bone to the parentBone
        bone.SetParent(parentBone, true);

        // add the bone name to the addedBones list
        addedBones.Add(missingBoneName);

        // add the bone to the addedBonesGameObjects list
        addedBonesGameObjects.Add(bone.gameObject);

        // debug log to console that the bone has been re-parented
        CoreLogDebug("[ArmatureLink][Bone re-parenting] Bone has been re-parented to: " + parentBone.name);
      }
      #endregion

      #region Added Bone rename
      // now all the addon bones have been re-parented to the avatar's armature, we need to rename them so duplicates
      // copies of the addon get their own copy of the bones

      // print the paths of all the addedBonesGameObjects to the console in one block
      StringBuilder addedBonesGameObjectsStringBuilder = new StringBuilder();
      foreach (GameObject addedBoneGameObject in addedBonesGameObjects)
      {
        addedBonesGameObjectsStringBuilder.Append(addedBoneGameObject.name + "\n");
      }
      CoreLogDebug(
        "[ArmatureLink][Bone Rename] addedBonesGameObjects:\n" + addedBonesGameObjectsStringBuilder.ToString()
      );

      // loop over the addedBonesGameObjects and rename them
      foreach (GameObject addedBoneGameObject in addedBonesGameObjects)
      {
        // get the bone name
        string boneName = addedBoneGameObject.name;

        // prefix the bone name with the DSUNumber
        addedBoneGameObject.name = "[CVRF_D" + DSUNumber + "]_" + boneName;

        // debug log to console that the bone has been renamed
        CoreLogDebug("Bone has been renamed to: " + addedBoneGameObject.name);

        // find the index of bone name in the addedBones list (List<string>)
        int index = addedBones.FindIndex(b => b == boneName);

        // replace the bone name in the addedBones list with the new bone name
        addedBones[index] = addedBoneGameObject.name;
      }

      #endregion


      // now all the bones have been added to the avatar's armature, we need to rebind the skinned mesh renderers
      // to the new armature at the boneToLinkTo


      #region Skinned mesh renderer rebind
      //  loop over the skinned mesh renderers and rebind them to the new armature
      foreach (SkinnedMeshRenderer skinnedMeshRendererToRebind in skinnedMeshRenderers)
      {
        // check if skinnedMeshRendererToRebind.bones is null, if it is then there is an issue, log an error to the console and continue to the next skinned mesh renderer
        if (skinnedMeshRendererToRebind.bones == null)
        {
          // log as a critical error to the console, as this should not happen
          CoreLogCritical(
            "[ArmatureLink][mesh rebind] Bones not found for skinned mesh renderer : "
              + skinnedMeshRendererToRebind.name
          );
        }
        else
        {
          // log as a debug to the console
          CoreLogDebug(
            "[ArmatureLink][mesh rebind] Bones found for skinned mesh renderer : " + skinnedMeshRendererToRebind.name
          );

          // get the bones of the skinned mesh renderer
          Transform[] bonesToRebind = skinnedMeshRendererToRebind.bones;

          // list the bones that are in the skinned mesh renderer in one block
          StringBuilder bonesToRebindStringBuilder = new StringBuilder();
          foreach (Transform boneToRebind in bonesToRebind)
          {
            bonesToRebindStringBuilder.Append(boneToRebind.name + "\n");
          }
          CoreLogDebug("[ArmatureLink][mesh rebind] bonesToRebind:\n" + bonesToRebindStringBuilder.ToString());

          // now we need only rebind bones that are common to the avatar and the addon (all the others
          // are already bound to the mesh so no point in messing with them) thus the 'commonBones' list
          // will be of help to filter the bones that need to be rebound (note that its just a list of names,
          // not actual bone refs)

          // create a list of bones to update from the bonesToRebind list that are in the commonBones list
          List<Transform> bonesToUpdate = new List<Transform>();

          // loop over the bonesToRebind and find the bones that are in the commonBones list
          foreach (Transform boneToRebind in bonesToRebind)
          {
            // check if the boneToRebind is in the commonBones list
            if (commonBones.Contains(boneToRebind.name))
            {
              // add the boneToRebind to the bonesToUpdate list
              bonesToUpdate.Add(boneToRebind);
            }
          }

          // print bonesToUpdate to console in one block
          StringBuilder bonesToUpdateStringBuilder = new StringBuilder();
          foreach (Transform boneToUpdate in bonesToUpdate)
          {
            bonesToUpdateStringBuilder.Append(boneToUpdate.name + "\n");
          }
          CoreLogDebug("[ArmatureLink][mesh rebind] bonesToUpdate:\n" + bonesToUpdateStringBuilder.ToString());

          // now we have the bones that need to be rebound, we need to rebind them to the new armature

          // loop over the bonesToUpdate and rebind them to the avatar's armature
          for (int i = 0; i < bonesToUpdate.Count; i++)
          {
            // find the bone in the avatarBones list
            Transform newBone = avatarBones.FirstOrDefault(b => b.name == bonesToUpdate[i].name);

            // if the newBone is null then there is an issue, log an error to the console and continue to the next bone
            if (newBone == null)
            {
              // log as a critical error to the console, as this should not happen
              CoreLogCritical("[ArmatureLink][mesh rebind] New bone not found for: " + bonesToUpdate[i].name);
              continue;
            }

            // find the bone in skinnedMeshRendererToRebind.bones via the name
            Transform oldBone = bonesToRebind.FirstOrDefault(b => b.name == bonesToUpdate[i].name);

            // replace the old bone in skinnedMeshRendererToRebind.bones with the new bone
            skinnedMeshRendererToRebind.bones = skinnedMeshRendererToRebind.bones
              .Select(b => b == oldBone ? newBone : b)
              .ToArray();

            // debug log to console that the bone has been rebound
            CoreLogDebug("[ArmatureLink][mesh rebind] Bone has been rebound to: " + newBone.name);
          }

          // only do this on the last past of the loop
          if (skinnedMeshRendererToRebind == skinnedMeshRenderers[skinnedMeshRenderers.Length - 1])
          {
            // now all common bones have been rebound on all skinnedMeshRenderers, in this set we need to get rid of
            // the old armature gameobject for optimisation purposes

            // get the parent of the armatureRoot
            Transform parent = armatureRoot.transform.parent;

            // destroy the armatureRoot
            GameObject.DestroyImmediate(armatureRoot);

            // debug log to console that the armatureRoot has been destroyed
            CoreLogDebug("[ArmatureLink][mesh rebind][Clean up] Addon Armature root has been destroyed");
          }
        }

        // even if no bones were found, we still need to rebind the root bone (and that is always there)
        skinnedMeshRendererToRebind.rootBone = boneToLinkToGameObject.transform;

        // check if the Anchor Override is set on the skinned mesh renderer, if it is then set it to the matching bone in the avatar's armature
        if (skinnedMeshRendererToRebind.probeAnchor != null)
        {
          // find the bone in the avatarBones list
          Transform anchorOverride = avatarBones.FirstOrDefault(
            b => b.name == skinnedMeshRendererToRebind.probeAnchor.name
          );

          // if the anchorOverride target is null then there is an issue, log an error to the console and continue to the next skinned mesh renderer
          if (anchorOverride == null)
          {
            // log as a critical error to the console, as this should not happen
            CoreLogCritical(
              "[ArmatureLink][mesh rebind] Anchor Override target not found for: "
                + skinnedMeshRendererToRebind.probeAnchor.name
            );
            continue;
          }

          // set the anchorOverride to the anchorOverride
          skinnedMeshRendererToRebind.probeAnchor = anchorOverride;

          // debug log to console that the skinned mesh renderer has been rebound
          CoreLogDebug("[ArmatureLink][mesh rebind] Skinned mesh renderer has been rebound to: " + anchorOverride.name);
        }
        else
        {
          // debug log to console that the skinned mesh renderer has been rebound
          CoreLogDebug(
            "[ArmatureLink][mesh rebind] Skinned mesh renderer has been rebound to: " + boneToLinkToGameObject.name
          );
        }

        // debug log to console that the skinned mesh renderer has been rebound
        CoreLogDebug(
          "[ArmatureLink][mesh rebind] Skinned mesh renderer has been rebound to: " + boneToLinkToGameObject.name
        );
      }

      #endregion

      #region Animation rebind
      // from the addonBoneNamesList we can get the bones that are in the addon's armature
      // given that we can use that as half the information we need to rebind the animations
      // the other half is the bones that are in the avatar's armature, we can get that from the avatarBones list
      // so we can loop over the addonBoneNamesList and find the corresponding bone in the avatarBones list
      // then we can update the animation clips to match the new bone structure

      // get the number of addonBoneNamesList entries
      int addonBoneNamesListCount = addonBoneNamesList.Count;

      // debug print the addonBoneNamesListCount
      CoreLogDebug("[ArmatureLink][animation rebind] addonBoneNamesListCount: " + addonBoneNamesListCount);

      // print addonBoneNamesList to console in one block
      StringBuilder addonBoneNamesListStringBuilder = new StringBuilder();
      foreach (string addonBoneName in addonBoneNamesList)
      {
        addonBoneNamesListStringBuilder.Append(addonBoneName + "\n");
      }
      CoreLogDebug(
        "[ArmatureLink][animation rebind] addonBoneNamesList:\n" + addonBoneNamesListStringBuilder.ToString()
      );

      // get the current avatar bone set (now we have added the missing bones)
      Transform[] updatedAvatarBones = boneToLinkToGameObject.GetComponentsInChildren<Transform>();

      // list of tuples to store the path of the bone in the addon's armature and the path of the bone in the avatar's armature
      List<ObjectPathPair> addonBonePaths = new List<ObjectPathPair>();

      // loop over the addonBoneNamesList
      foreach (string addonBoneNameInput in addonBoneNamesList)
      {
        // get the addonBoneName (needs to be a separate variable as some times need to modify it later on)
        string addonBoneName = addonBoneNameInput;
        // debug print the name of the bone
        CoreLogDebug("[ArmatureLink][animation rebind] addonBoneName: " + addonBoneName);

        // check if the bone name is in the commonBones list
        if (!commonBones.Contains(addonBoneName))
        {
          // not a common bone, so need to apply the rename
          // add the prefix to the addonBoneName
          addonBoneName = "[CVRF_D" + DSUNumber + "]_" + addonBoneName;
        }
        else
        {
          // common bone, so no need to apply the rename
          // debug print that the bone is a common bone
          CoreLogDebug("[ArmatureLink][animation rebind] Common bone: " + addonBoneName);
        }

        // get the path of the bone in the avatar's armature
        string avatarBonePathBase = GetBonePath(updatedAvatarBones, addonBoneName);

        //  remove the avatarPath from the start of the avatarBonePath
        string avatarBonePath = avatarBonePathBase.Replace(avatarPath, "");

        // remove the starting `/` from the avatarBonePath if it exists
        if (avatarBonePath.StartsWith("/"))
        {
          avatarBonePath = avatarBonePath.Substring(1);
        }

        // TODO: remove this debug print
        // // debug print the path of the bone in the avatar's armature
        // CoreLogDebug("[ArmatureLink][animation rebind] avatarBonePath: " + avatarBonePath);


        // get the base path of the addon GameObject
        string addonBasePath = addonObjectToLinkPath;

        // remove the leaf from the addonBasePath
        int lastSlashIndex = addonBasePath.LastIndexOf("/");
        addonBasePath = addonBasePath.Substring(0, lastSlashIndex);

        // remove the animatorObjectPath from the start of the addonBasePath
        addonBasePath = addonBasePath.Replace(animatorObjectPath, "");

        // remove the starting `/` from the addonBasePath if it exists
        if (addonBasePath.StartsWith("/"))
        {
          addonBasePath = addonBasePath.Substring(1);
        }

        // TODO: remove this debug print
        // // Debug print the boneToLinkToGameObject.name
        // CoreLogDebug("[ArmatureLink][animation rebind] boneToLinkToGameObject.name: " + boneToLinkToGameObject.name);

        // Append the name of boneToLinkToGameObject to the addonBasePath
        string addonBonePath = addonBasePath + "/" + boneToLinkToGameObject.name;

        //
        int index = avatarBonePath.IndexOf(boneToLinkToGameObject.name);

        if (index != -1)
        {
          addonBonePath = addonBonePath + avatarBonePath.Substring(index + boneToLinkToGameObject.name.Length);
        }
        else
        {
          // log as a critical error to the console, as this should not happen
          CoreLogCritical(
            "[ArmatureLink][animation rebind] Bone not found in avatar armature: " + boneToLinkToGameObject.name
          );
          // continue to the next bone
          continue;
        }

        // TODO: remove this debug print
        // // debug print the base addon path
        // CoreLogDebug("addonBonePath: " + addonBonePath);

        // remove all instances of the prefix from the addonBonePath (as we need the original path for the
        // animation rebind)
        addonBonePath = addonBonePath.Replace("[CVRF_D" + DSUNumber + "]_", "");

        // add the addonBonePath and avatarBonePath to the addonBonePaths list
        addonBonePaths.Add(
          new ObjectPathPair { addonObjectToLinkPath = addonBonePath, newAddonObjectToLinkPath = avatarBonePath }
        );
      }

      // get the number of addonBonePaths entries
      int addonBonePathsCount = addonBonePaths.Count;
      // debug print the addonBonePathsCount
      CoreLogDebug("[ArmatureLink][animation rebind] addonBonePathsCount: " + addonBonePathsCount);

      // print all the addonBonePaths to console in one block
      StringBuilder addonBonePathsStringBuilder = new StringBuilder();
      foreach (ObjectPathPair objectPathPair in addonBonePaths)
      {
        addonBonePathsStringBuilder.Append(
          "addonPath: "
            + objectPathPair.addonObjectToLinkPath
            + ", avatarPath: "
            + objectPathPair.newAddonObjectToLinkPath
            + "\n"
        );
      }
      CoreLogDebug("[ArmatureLink][animation rebind] addonBonePaths:\n" + addonBonePathsStringBuilder.ToString());

      // create a list of tuples to store the addonBoneObjectPath and the newAddonBoneObjectPath
      List<System.Tuple<string, string>> addonBonePathsTuple = addonBonePaths
        .Select(pair => new System.Tuple<string, string>(pair.addonObjectToLinkPath, pair.newAddonObjectToLinkPath))
        .ToList();

      // mass update the animation clips (multi path per save)
      UpdateAnimationClips(avatar.name, addonBonePathsTuple, DSUNumber);

      // only need to do the asset db refresh once, at the end of the loop
      AssetDatabase.Refresh();

      #endregion
    }

    private void performReparentRoot(
      CVRAvatar avatar,
      GameObject DSUObject,
      int DSUNumber,
      armatureLink armatureLinkModule
    )
    {
      // Implementation for performReparentRoot
      // console print to say this function is being called
      CoreLog("[ArmatureLink] performReparentRoot() called");

      // call function to add the CVRFuryGameObjectInfoTag to the DSUObject + children
      AddCVRFuryGameObjectInfoTagToAddon(DSUObject, DSUNumber);

      // get the path to the avatar
      string avatarPath = GetGameObjectPath(avatar.gameObject);

      // get the current path of the addonObjectToLink and store it
      string addonObjectToLinkPath = GetGameObjectPath(armatureLinkModule.addonObjectToLink);

      // remove the avatarPath from the start of the addonObjectToLinkPath
      addonObjectToLinkPath = addonObjectToLinkPath.Replace(avatarPath, "");

      // remove the starting `/` from the addonObjectToLinkPath if it exists
      if (addonObjectToLinkPath.StartsWith("/"))
      {
        addonObjectToLinkPath = addonObjectToLinkPath.Substring(1);
      }

      // move the addonObjectToLink to be a child of the armatureBoneToLinkTo, note armatureBoneToLinkTo is of
      // type HumanBodyBones, the addonObjectToLink is of type GameObject and the addonObjectToLink should not move in
      // scene space but just be parented to the bone (this is so the user can position the object where they want it)

      // get the Animator component from the avatar
      Animator animator = avatar.GetComponent<Animator>();

      // get the HumanBodyBones enum value from the armatureBoneToLinkTo
      HumanBodyBones boneToLinkTo = armatureLinkModule.armatureBoneToLinkTo;

      // get the GameObject of the boneToLinkTo
      GameObject boneToLinkToGameObject = animator.GetBoneTransform(boneToLinkTo).gameObject;

      // add a empty GameObject to the boneToLinkToGameObject, this is for insulation purposes
      GameObject addonParent = new GameObject("CVRF_Addon_" + DSUNumber);

      // put the addonParent as a child of the boneToLinkToGameObject
      addonParent.transform.SetParent(boneToLinkToGameObject.transform, true);

      // put the addonObjectToLink as a child of the boneToLinkToGameObject
      armatureLinkModule.addonObjectToLink.transform.SetParent(boneToLinkToGameObject.transform, true);

      // copy the position/rotation/scale of the addonObjectToLink to the addonParent
      addonParent.transform.position = armatureLinkModule.addonObjectToLink.transform.position;
      addonParent.transform.rotation = armatureLinkModule.addonObjectToLink.transform.rotation;
      addonParent.transform.localScale = armatureLinkModule.addonObjectToLink.transform.localScale;

      // reparent the addonObjectToLink to the addonParent
      armatureLinkModule.addonObjectToLink.transform.SetParent(addonParent.transform, true);

      // debug log to console that the object has been re-parented
      CoreLogDebug("[ArmatureLink] Object has been re-parented to: " + boneToLinkToGameObject.name);

      // ok now to take care of any duplicates (people may want more than one of the same object), we need to
      // add a tag to the start of the object name to make it unique

      // get the name of the addonObjectToLink
      string addonObjectToLinkName = armatureLinkModule.addonObjectToLink.name;

      // new name of the addonObjectToLink
      string newAddonObjectToLinkName = "[CVRF_D" + DSUNumber + "]_" + addonObjectToLinkName;

      // prefix the name of the addonObjectToLink with the DSUNumber
      armatureLinkModule.addonObjectToLink.name = newAddonObjectToLinkName;

      // console print to say renaming is done
      CoreLog("[ArmatureLink] Renaming from " + addonObjectToLinkName + " to " + newAddonObjectToLinkName + " done");

      // get the new path of the addonObjectToLink and store it
      string newAddonObjectToLinkPath = GetGameObjectPath(armatureLinkModule.addonObjectToLink);

      // remove the avatarPath from the start of the newAddonObjectToLinkPath
      newAddonObjectToLinkPath = newAddonObjectToLinkPath.Replace(avatarPath, "");

      // remove the starting `/` from the newAddonObjectToLinkPath if it exists
      if (newAddonObjectToLinkPath.StartsWith("/"))
      {
        newAddonObjectToLinkPath = newAddonObjectToLinkPath.Substring(1);
      }

      // debug log to console the new path of the addonObjectToLink
      CoreLogDebug("[ArmatureLink] newAddonObjectToLinkPath: " + newAddonObjectToLinkPath);

      // ok, so now we have the new path of the addonObjectToLink, that is the base for re-writing the animation clips
      // note the animations packaged with the addon will be expected to start from that as a root

      // get the DSU component from the DSUObject
      CVRFuryDataStorageUnit DSUComponent = DSUObject.GetComponent<CVRFuryDataStorageUnit>();

      // check if the modules of the DSUComponent  and see if there is a fullControllerModule type module present
      if (DSUComponent.modules.modules.Any(m => m.ModuleType == "fullControllerModule"))
      {
        // of so there is a fullControllerModule type module present,

        // get the fullControllerModule from the DSUComponent
        fullControllerModule controllerModule =
          DSUComponent.modules.modules.FirstOrDefault(m => m.ModuleType == "fullControllerModule")
          as fullControllerModule;

        // check if the fullControllerModule is null, if it is then there is an issue, log an error to the console and return
        if (controllerModule == null)
        {
          CoreLogError("fullControllerModule is null, cannot rebind animations");
          return;
        }

        // get the controllers from the fullControllerModule
        List<RuntimeAnimatorController> controllers = controllerModule.controllers;

        // check if the controllers is null or empty, if it is then looks like there are no animations to rebind,
        // log a warning to the console and return
        if (controllers == null || controllers.Count == 0)
        {
          // log as a warning to the console
          CoreLog("[Warning] controllers is null or empty, no animations to rebind");
          return;
        }

        // at this point there is at least one controller in the controllers list, so there should be animations to
        // rebind. so w need to check if there is a folder for the animations, if there is not then there is an issue,
        // log an error to the console and return

        // the folder path for the animations
        string animationsFolderPath =
          Constants.ASSETS_MANAGED_FOLDER_GENERATED + avatar.name + "/temp_items/DSU-" + DSUNumber + "/";

        // debug print the animationsFolderPath
        CoreLogDebug("[ArmatureLink] animationsFolderPath: " + animationsFolderPath);

        // get a list of all files in the animationsFolderPath
        string[] animationFiles = Directory.GetFiles(animationsFolderPath);

        // remove all files that are not animation animationFiles from the animationFiles list
        animationFiles = animationFiles.Where(f => f.EndsWith(".anim")).ToArray();

        // remove all animationFiles that have '_clip_gen_pre_' in the name from the animationFiles list
        animationFiles = animationFiles.Where(f => !f.Contains("_clip_gen_pre_")).ToArray();

        // check if the animationFiles is null or empty, if it is then there is an issue, log an error to the console and return
        if (animationFiles == null || animationFiles.Length == 0)
        {
          // log as an error to the console
          CoreLogError("animationFiles is null or empty, no animations to rebind");
          return;
        }

        // debug print the list of animationFiles to console in one block
        StringBuilder animationFilesStringBuilder = new StringBuilder();
        foreach (string animationFile in animationFiles)
        {
          animationFilesStringBuilder.Append(animationFile + "\n");
        }
        CoreLogDebug("[ArmatureLink] animationFiles:\n" + animationFilesStringBuilder.ToString());

        // at this point there is at least one animation file in the animationFiles array, so there should be animations
        // to rebind. so we need to loop over them and re-write the paths

        // ObjectPathPair list to store the addonObjectToLinkPath and the newAddonObjectToLinkPath
        List<ObjectPathPair> objectPathPairs = new List<ObjectPathPair>();

        // loop over the animationFiles and rebind the paths
        foreach (string animationFile in animationFiles)
        {
          // print to console that the animation file is being processed
          CoreLog("[ArmatureLink] Processing animation file: " + animationFile);

          // load the animation clip from the animationFile
          AnimationClip clip = AssetDatabase.LoadAssetAtPath<AnimationClip>(animationFile);

          // get all the paths in the clip
          EditorCurveBinding[] curveBindings = AnimationUtility.GetCurveBindings(clip);
          EditorCurveBinding[] objectReferenceCurveBindings = AnimationUtility.GetObjectReferenceCurveBindings(clip);

          // merge curveBindings and objectReferenceCurveBindings
          EditorCurveBinding[] allCurveBindings = curveBindings.Concat(objectReferenceCurveBindings).ToArray();

          // overwrite the curveBindings with the allCurveBindings (so we can use the same loop for both)
          curveBindings = allCurveBindings;

          // debug print all the curveBindings to console in one block
          StringBuilder curveBindingsStringBuilder = new StringBuilder();
          foreach (EditorCurveBinding curveBinding in curveBindings)
          {
            curveBindingsStringBuilder.Append(
              "path: "
                + curveBinding.path
                + ", propertyName: "
                + curveBinding.propertyName
                + ", type: "
                + curveBinding.type
                + "\n\n"
            );
          }
          CoreLogDebug("[ArmatureLink] curveBindings:\n\n" + curveBindingsStringBuilder.ToString());

          // exclude any curveBindings that don't have the DSU component 'prefabName' in the path
          // (this is because we only want to impact the animations that are related to the DSUObject
          // and not paths that the addon maker intended to impact the core armature)
          curveBindings = curveBindings.Where(cb => cb.path.Contains(addonObjectToLinkName)).ToArray();

          // debug print the count of the curveBindings
          CoreLogDebug("[ArmatureLink] curveBindings count: " + curveBindings.Length);

          // prefix the path of the curveBindings with the newAddonObjectToLinkPath
          foreach (EditorCurveBinding curveBinding in curveBindings)
          {
            // get the path of the curveBinding
            string path = curveBinding.path;

            CoreLogDebug("[ArmatureLink] path: " + path);

            // get the trailing part of the path (if it exists) after the prefabName as currently processed
            // remove the addonObjectToLinkName from the stat of the path
            string trailingPath = path.Substring(path.IndexOf(addonObjectToLinkName) + addonObjectToLinkName.Length);

            // string trailingPath = path.Substring(
            //   path.IndexOf(DSUComponent.prefabName) + DSUComponent.prefabName.Length
            // );

            CoreLogDebug(
              "[ArmatureLink] addon object name : "
                + addonObjectToLinkName
                + "\n trailingPath stage 1: "
                + trailingPath
                + "\n, DSUComponent.prefabName: "
                + DSUComponent.prefabName
                + "\n, DSUComponent.prefabName.Length: "
                + DSUComponent.prefabName.Length
            );

            // only do this bit if we have an imported module
            // (the converter adds the suffix .CVRFury by default to differentiate it from the original prefab)
            if (controllerModule.importedFromVRCFury)
            {
              // if the trailing path is '.CVRFury' then we have a root addon object, so can ignore that bit
              // remove the '.CVRFury' from the trailingPath if it exists
              if (trailingPath.StartsWith(".CVRFury"))
              {
                trailingPath = trailingPath.Substring(".CVRFury".Length);
              }
              CoreLogDebug("[ArmatureLink] trailingPath stage 2 (import cleanup): " + trailingPath);
            }

            // check for empty trailingPath
            if (!string.IsNullOrEmpty(trailingPath))
            {
              // not null or empty, so we need to prefix the trailingPath with the newAddonObjectToLinkPath
              // ensure the trailingPath starts with a `/`
              if (!trailingPath.StartsWith("/"))
              {
                trailingPath = "/" + trailingPath;
              }
            }

            //debug print the paths of the curveBinding
            CoreLogDebug(
              "[ArmatureLink] addonPath: "
                + addonObjectToLinkPath
                + "\n, targetPath: "
                + newAddonObjectToLinkPath
                + "\n, trailingPath stage 3 (final): "
                + trailingPath
            );

            objectPathPairs.Add(
              new ObjectPathPair
              {
                addonObjectToLinkPath = path,
                newAddonObjectToLinkPath = newAddonObjectToLinkPath + trailingPath
              }
            );
          }

          // debug log to console that the animation file has been re-written
          CoreLog("[ArmatureLink] Animation paths updates from  '" + animationFile + "' stored");
        }

        // deduplicate the objectPathPairs list
        objectPathPairs = objectPathPairs.Distinct().ToList();

        // print all the objectPathPairs to console in one block
        StringBuilder objectPathPairsStringBuilder = new StringBuilder();
        foreach (ObjectPathPair objectPathPair in objectPathPairs)
        {
          objectPathPairsStringBuilder.Append(
            "addonPath: "
              + objectPathPair.addonObjectToLinkPath
              + ",\n avatarPath: "
              + objectPathPair.newAddonObjectToLinkPath
              + "\n\n"
          );
        }
        CoreLogDebug("[ArmatureLink] objectPathPairs:\n" + objectPathPairsStringBuilder.ToString());

        // create a list of tuples to store the addonObjectToLinkPath and the newAddonObjectToLinkPath
        List<System.Tuple<string, string>> objectPathPairsTuple = objectPathPairs
          .Select(pair => new System.Tuple<string, string>(pair.addonObjectToLinkPath, pair.newAddonObjectToLinkPath))
          .ToList();

        // mass update the animation clips (multi path per save)
        UpdateAnimationClips(avatar.name, objectPathPairsTuple, DSUNumber);

        // log that the animation clips have been updated
        CoreLog("[ArmatureLink] Animation clips updated");

        // at this point all the animation files have been re-written, so we need to save/refresh the asset database

        // save the asset database
        AssetDatabase.SaveAssets();
        // update the asset database
        AssetDatabase.Refresh();
      }
    }

    // -----------------------------------------------------------------------------------------------------------------
    #region Helper Functions/structs

    public string GetBonePath(Transform[] avatarBones, string boneName)
    {
      // Implementation for GetBonePath
      // console print to say this function is being called
      CoreLog("GetBonePath() called");

      // get the bone from the avatarBones array
      Transform bone = avatarBones.FirstOrDefault(b => b.name == boneName);

      // if the bone is null then there is an issue, log an error to the console and return an empty string
      if (bone == null)
      {
        // log as an error to the console
        CoreLogError("Bone not found: " + boneName);
        return "";
      }

      // get the path of the bone
      string path = GetGameObjectPath(bone.gameObject);

      // return the path of the bone
      return path;
    }

    public void AddCVRFuryGameObjectInfoTagToAddon(GameObject DSUObject, int DSUNumber)
    {
      // check if the DSUObject has a CVRFuryDataStorageUnit component, if it does not then return
      if (DSUObject.GetComponent<CVRFuryDataStorageUnit>() == null)
      {
        CoreLogError("DSUObject does not have a CVRFuryDataStorageUnit component, cannot add CVRFuryGameObjectInfoTag");
        return;
      }

      // get the prefabName from the DSU component of the DSUObject
      string prefabName = DSUObject.GetComponent<CVRFuryDataStorageUnit>().prefabName;

      // check if the prefabName is null or empty, if it is then return
      if (string.IsNullOrEmpty(prefabName))
      {
        CoreLogError("prefabName is null or empty, cannot add CVRFuryGameObjectInfoTag");
        return;
      }

      // debug log to console the prefabName
      CoreLogDebug("prefabName: " + prefabName);

      // get the list of all children of the DSUObject
      List<GameObject> children = DSUObject.GetAllChildGameObjects();

      // loop over the children of the DSUObject and add the CVRFuryGameObjectInfoTag component to each child
      foreach (GameObject child in children)
      {
        // check if the child has a CVRFuryGameObjectInfoTag component, if it does not then add it
        if (child.GetComponent<CVRFuryGameObjectInfoTag>() == null)
        {
          child.AddComponent<CVRFuryGameObjectInfoTag>();
        }

        // get the CVRFuryGameObjectInfoTag component from the child
        CVRFuryGameObjectInfoTag CVRFuryGameObjectInfoTag = child.GetComponent<CVRFuryGameObjectInfoTag>();

        // set the sourcePrefabName on the CVRFuryGameObjectInfoTag component
        CVRFuryGameObjectInfoTag.sourcePrefabName = prefabName;

        // set the DSUNumber on the CVRFuryGameObjectInfoTag component
        CVRFuryGameObjectInfoTag.sourceDSUNumber = DSUNumber;
      }

      // add the CVRFuryGameObjectInfoTag component to the DSUObject
      if (DSUObject.GetComponent<CVRFuryGameObjectInfoTag>() == null)
      {
        DSUObject.AddComponent<CVRFuryGameObjectInfoTag>();
      }
      // set the sourcePrefabName on the CVRFuryGameObjectInfoTag component
      DSUObject.GetComponent<CVRFuryGameObjectInfoTag>().sourcePrefabName = prefabName;

      // set the DSUNumber on the CVRFuryGameObjectInfoTag component
      DSUObject.GetComponent<CVRFuryGameObjectInfoTag>().sourceDSUNumber = DSUNumber;
    }

    public void UpdateAnimationClips(string avatarName, List<System.Tuple<string, string>> pathPairs, int DSUNumber)
    {
      string animationClipsFolder =
        Constants.ASSETS_MANAGED_FOLDER_GENERATED + avatarName + "/temp_items/DSU-" + DSUNumber + "/";

      if (!Directory.Exists(animationClipsFolder))
      {
        CoreLogError("Animation clips folder does not exist: " + animationClipsFolder);
        return;
      }

      foreach (var pathPair in pathPairs)
      {
        if (string.IsNullOrEmpty(pathPair.Item1) || string.IsNullOrEmpty(pathPair.Item2))
        {
          CoreLogError("One of the paths in the pair is null or empty");
          return;
        }
      }

      CoreLogDebug("Animation clips folder: " + animationClipsFolder);

      foreach (string animationClipPath in Directory.GetFiles(animationClipsFolder))
      {
        if (!File.Exists(animationClipPath))
        {
          CoreLogCritical("File does not exist: " + animationClipPath);
          continue;
        }

        if (!animationClipPath.EndsWith(".anim"))
        {
          // don't process non animation files
          continue;
        }

        if (animationClipPath.Contains("_clip_gen_pre_"))
        {
          // don't process 'pre' files
          continue;
        }

        AnimationClip clip = AssetDatabase.LoadAssetAtPath<AnimationClip>(animationClipPath);
        EditorCurveBinding[] curveBindings = AnimationUtility.GetCurveBindings(clip);

        foreach (EditorCurveBinding curveBinding in curveBindings)
        {
          foreach (var pathPair in pathPairs)
          {
            if (curveBinding.path == pathPair.Item1)
            {
              EditorCurveBinding newCurveBinding = new EditorCurveBinding
              {
                path = pathPair.Item2,
                type = curveBinding.type,
                propertyName = curveBinding.propertyName
              };

              AnimationCurve curve = AnimationUtility.GetEditorCurve(clip, curveBinding);
              AnimationUtility.SetEditorCurve(clip, curveBinding, null);
              AnimationUtility.SetEditorCurve(clip, newCurveBinding, curve);
            }
          }
        }
        // debug log to console that the animation file has been re-written for the curveBindings
        CoreLogDebug(
          "[ArmatureLink] Animation paths updates from  '" + animationClipPath + "' re-written for the curveBindings"
        );

        // Code for handling 'PPtrCurves'
        EditorCurveBinding[] objectReferenceCurveBindings = AnimationUtility.GetObjectReferenceCurveBindings(clip);

        foreach (EditorCurveBinding objectReferenceCurveBinding in objectReferenceCurveBindings)
        {
          foreach (var pathPair in pathPairs)
          {
            if (objectReferenceCurveBinding.path == pathPair.Item1)
            {
              EditorCurveBinding newObjectReferenceCurveBinding = new EditorCurveBinding
              {
                path = pathPair.Item2,
                type = objectReferenceCurveBinding.type,
                propertyName = objectReferenceCurveBinding.propertyName
              };

              ObjectReferenceKeyframe[] curve = AnimationUtility.GetObjectReferenceCurve(
                clip,
                objectReferenceCurveBinding
              );
              AnimationUtility.SetObjectReferenceCurve(clip, objectReferenceCurveBinding, null);
              AnimationUtility.SetObjectReferenceCurve(clip, newObjectReferenceCurveBinding, curve);
            }
          }
        }

        // debug log to console that the animation file has been re-written for the objectReferenceCurveBindings
        CoreLogDebug(
          "[ArmatureLink] Animation paths updates from  '"
            + animationClipPath
            + "' re-written for the objectReferenceCurveBindings"
        );

        AssetDatabase.SaveAssets();
        EditorUtility.SetDirty(clip);
      }
    }

    public void UpdateAnimationClips(
      string avatarName,
      string addonObjectToLinkPath,
      string newAddonObjectToLinkPath,
      int DSUNumber
    )
    {
      string animationClipsFolder =
        Constants.ASSETS_MANAGED_FOLDER_GENERATED + avatarName + "/temp_items/DSU-" + DSUNumber + "/";

      if (!Directory.Exists(animationClipsFolder))
      {
        CoreLogError("Animation clips folder does not exist: " + animationClipsFolder);
        return;
      }

      // if the addonObjectToLinkPath and newAddonObjectToLinkPath are the same then return
      if (addonObjectToLinkPath == newAddonObjectToLinkPath)
      {
        CoreLogDebug("No animation rebind needed as Object has not moved");
        return;
      }

      // if addonObjectToLinkPath is null or empty then return
      if (string.IsNullOrEmpty(addonObjectToLinkPath))
      {
        CoreLogError("addonObjectToLinkPath is null or empty");
        return;
      }

      // if newAddonObjectToLinkPath is null or empty then return
      if (string.IsNullOrEmpty(newAddonObjectToLinkPath))
      {
        CoreLogError("newAddonObjectToLinkPath is null or empty");
        return;
      }

      CoreLogDebug("Animation clips folder: " + animationClipsFolder);

      foreach (string animationClipPath in Directory.GetFiles(animationClipsFolder))
      {
        if (!File.Exists(animationClipPath))
        {
          CoreLogCritical("File does not exist: " + animationClipPath);
          continue;
        }

        if (!animationClipPath.EndsWith(".anim"))
        {
          // don't process non animation files
          continue;
        }

        if (animationClipPath.Contains("_clip_gen_pre_"))
        {
          // don't process 'pre' files
          continue;
        }

        CoreLogDebug("addonObjectToLinkPath: " + addonObjectToLinkPath);
        CoreLogDebug("newAddonObjectToLinkPath: " + newAddonObjectToLinkPath);

        AnimationClip clip = AssetDatabase.LoadAssetAtPath<AnimationClip>(animationClipPath);
        EditorCurveBinding[] curveBindings = AnimationUtility.GetCurveBindings(clip);

        foreach (EditorCurveBinding curveBinding in curveBindings)
        {
          CoreLogDebug("Current curveBinding.path: " + curveBinding.path);

          if (curveBinding.path == addonObjectToLinkPath)
          {
            EditorCurveBinding newCurveBinding = new EditorCurveBinding
            {
              path = newAddonObjectToLinkPath,
              type = curveBinding.type,
              propertyName = curveBinding.propertyName
            };

            AnimationCurve curve = AnimationUtility.GetEditorCurve(clip, curveBinding);
            AnimationUtility.SetEditorCurve(clip, curveBinding, null);
            AnimationUtility.SetEditorCurve(clip, newCurveBinding, curve);
          }
        }

        // Code for handling 'PPtrCurves'
        EditorCurveBinding[] objectReferenceCurveBindings = AnimationUtility.GetObjectReferenceCurveBindings(clip);

        foreach (EditorCurveBinding objectReferenceCurveBinding in objectReferenceCurveBindings)
        {
          CoreLogDebug("Current objectReferenceCurveBinding.path: " + objectReferenceCurveBinding.path);

          if (objectReferenceCurveBinding.path == addonObjectToLinkPath)
          {
            EditorCurveBinding newObjectReferenceCurveBinding = new EditorCurveBinding
            {
              path = newAddonObjectToLinkPath,
              type = objectReferenceCurveBinding.type,
              propertyName = objectReferenceCurveBinding.propertyName
            };

            ObjectReferenceKeyframe[] curve = AnimationUtility.GetObjectReferenceCurve(
              clip,
              objectReferenceCurveBinding
            );
            AnimationUtility.SetObjectReferenceCurve(clip, objectReferenceCurveBinding, null);
            AnimationUtility.SetObjectReferenceCurve(clip, newObjectReferenceCurveBinding, curve);
          }
        }

        AssetDatabase.SaveAssets();
        EditorUtility.SetDirty(clip);
      }
    }

    // struct to store bone data (name and parent name)
    public struct BoneData
    {
      public string name;
      public string parentName;
    }

    // struct to store object path pairs
    public struct ObjectPathPair
    {
      public string addonObjectToLinkPath;
      public string newAddonObjectToLinkPath;
    }

    #endregion
  }
}
// #endif
