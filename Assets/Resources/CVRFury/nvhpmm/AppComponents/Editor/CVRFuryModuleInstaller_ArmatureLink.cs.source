// { "version": "0.0.100" , "canInstall": true , "optional": true , "defineSymbolSuffix": "_MI_AL", dependencies: []}
// #if UNITY_EDITOR && CVR_CCK_EXISTS

using Math = System.Math;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System.IO;
using UnityEditor;
using UnityEditor.Animations;
using UnityEditor.UIElements;
using UnityEngine;
using UnityEngine.UIElements;
using UnityEngine.SceneManagement;
using uk.novavoidhowl.dev.cvrfury.runtime;
using ABI.CCK.Scripts.Editor;
using ABI.CCK.Scripts;
using ABI.CCK.Components;
using Constants = uk.novavoidhowl.dev.cvrfury.packagecore.Constants;
using static uk.novavoidhowl.dev.cvrfury.packagecore.CoreUtils;
using static uk.novavoidhowl.dev.cvrfury.deployable.ReportBuilderSupport;
using static uk.novavoidhowl.dev.cvrfury.supporting_classes.editor.Animation;
using static uk.novavoidhowl.dev.cvrfury.supporting_classes.runtime.General;

// temp using for testing
using System.Text;

/// <summary>
/// armatureLink Module
/// this is handles binding objects to the armature of the avatar and merging addon armatures
/// </summary>

namespace uk.novavoidhowl.dev.cvrfury.deployable
{
  public class armatureLinkModuleProcessor : IModuleProcessor
  {
    public void ProcessModule(CVRFuryModule module, GameObject targetAvatar, int DSUNumber, GameObject DSUObject)
    {
      // Implementation for armatureLinkModuleProcessor
      // console print to say this function is being called
      CoreLog("armatureLinkModuleProcessor.ProcessModule() called");

      // log the module's moduleType to the console
      CoreLog("module.ModuleType: " + module.ModuleType);

      // access the CVRAvatar component on the targetAvatar
      CVRAvatar avatar = targetAvatar.GetComponent<CVRAvatar>();

      // check if the avatar exists
      if (avatar != null)
      {
        // we have the avatar, and it is valid,

        // bool to say if we have need mesh rebind mode
        bool needsMeshRebind = true;

        // check if there are any animator components on the DSUObject or any of its children
        if (DSUObject.GetComponent<Animator>() == null && DSUObject.GetComponentsInChildren<Animator>().Length == 0)
        {
          // if there are no animator components on the DSUObject or any of its children, then we don't need mesh rebind
          needsMeshRebind = false;
        }

        // cast the module to a armatureLinkModule
        armatureLink armatureLinkModule = (armatureLink)module;

        switch (armatureLinkModule.addonLinkMode)
        {
          case CVRFuryModuleLinker.linkMode.MeshRebind:
            // Handle MeshRebind case
            // this needs to compare the avatar's armature to the armature linked to skinned mesh renderers in/under
            // the DSUObject, and then merge the too armatures together adding in any missing bones, then rebind the
            // skinned mesh renderers to the new armature
            // note this needs to start at the bone specified in the armatureBoneToLinkTo (this being a unity standard
            // bone name) and put the two armatures together from there

            performMeshRebind(avatar, DSUObject, DSUNumber, armatureLinkModule);
            break;
          case CVRFuryModuleLinker.linkMode.MergeAsChildren:
            // Deprecated, but kept for redirecting to MeshRebind
            // Handle MergeAsChildren case
            // redirect to the same as MeshRebind
            performMeshRebind(avatar, DSUObject, DSUNumber, armatureLinkModule);
            break;
          case CVRFuryModuleLinker.linkMode.ParentConstraint:
            // Deprecated, but kept for redirecting to MeshRebind
            // Handle ParentConstraint case
            // redirect to the same as MeshRebind
            performMeshRebind(avatar, DSUObject, DSUNumber, armatureLinkModule);
            break;
          case CVRFuryModuleLinker.linkMode.ReparentRoot:
            // Handle ReparentRoot case
            // this needs to move the addonObjectToLink to be a child of the armatureBoneToLinkTo while keeping the
            // object's position and rotation relative to the bone
            performReparentRoot(avatar, DSUObject, DSUNumber, armatureLinkModule);
            break;
          case CVRFuryModuleLinker.linkMode.Auto:
            // Handle Auto case
            // this needs to check if the DSUObject has any skinned mesh renderers, if it does then it should use
            // MeshRebind, if it doesn't then it should use ReparentRoot
            if (needsMeshRebind)
            {
              performMeshRebind(avatar, DSUObject, DSUNumber, armatureLinkModule);
            }
            else
            {
              performReparentRoot(avatar, DSUObject, DSUNumber, armatureLinkModule);
            }
            break;
          default:
            // Handle unexpected case
            // log a critical error to the console (should be impossible to reach this point)
            CoreLogCritical(
              "Unexpected module.addonLinkMode: "
                + armatureLinkModule.addonLinkMode
                + " this should not happen, please report this to the developer"
            );
            break;
        }
      }
    }

    private void performMeshRebind(CVRAvatar avatar, GameObject DSUObject, int DSUNumber, armatureLink armatureLinkModule)
    {
      // Implementation for performMeshRebind
      // console print to say this function is being called
      CoreLog("performMeshRebind() called");

      // call function to add the CVRFuryGameObjectInfoTag to the DSUObject + children
      AddCVRFuryGameObjectInfoTagToAddon(DSUObject, DSUNumber);

      // get the path to the avatar
      string avatarPath = GetGameObjectPath(avatar.gameObject);

      // get the current path of the addonObjectToLink and store it
      string addonObjectToLinkPath = GetGameObjectPath(armatureLinkModule.addonObjectToLink);

      // get the new path of the addonObjectToLink and store it
      string newAddonObjectToLinkPath = GetGameObjectPath(armatureLinkModule.addonObjectToLink);

      // ok this is mesh rebind mode, so first we need to figure out what sub object is the root of the addon armature
      // so check if there are any animator components on the DSUObject or any of its children
      if (DSUObject.GetComponent<Animator>() == null && DSUObject.GetComponentsInChildren<Animator>().Length == 0)
      {
        // if there are no animator components on the DSUObject or any of its children, then we can't do mesh rebind
        // log an error to the console and return
        CoreLogError("No Animator component found on DSUObject or any of its children, cannot perform mesh rebind");
        return;
      }

      // TODO: need to figure out how to handle the case of multiple animator components on the DSUObject or its children
      // for now just get the first one from only the DSUObject

      // check if there is not an animator component on the DSUObject and if so abort
      if (DSUObject.GetComponent<Animator>() == null)
      {
        // log an error to the console and return
        CoreLogError("No Animator component found on DSUObject, cannot perform mesh rebind");
        return;
      }

      // at this point we know there is an animator component on the DSUObject, so check if it has a avatar assigned
      if (DSUObject.GetComponent<Animator>().avatar == null)
      {
        // log an error to the console and return
        CoreLogError("No Avatar assigned to Animator component on DSUObject, cannot perform mesh rebind");
        return;
      }

      // get the gameobject of the AddonObjectToLink
      GameObject addonObjectToLink = armatureLinkModule.addonObjectToLink;

      // finding the root of the armature
      // Start with the addonObjectToLink
      Transform current = addonObjectToLink.transform;

      // Walk up the hierarchy until we reach the top
      while (current.parent != null && current.parent != DSUObject.transform)
      {
        current = current.parent;
      }

      // current is now the root GameObject of the armature, so now we can use that for exclusion purposes
      GameObject armatureRoot = current.gameObject;

      // now all animations will have been made assuming the base is the same object that has the Animator component
      // but now we are adding it to an avatar, so we need to adjust the paths of the animations to match the new
      // hierarchy

      // first we need a list of all the objects directly under the object that the animator is on, but that do not
      // include the armatureRoot object
      List<GameObject> objectsToRebind = new List<GameObject>();
      foreach (Transform child in DSUObject.transform)
      {
        if (child.gameObject != armatureRoot)
        {
          objectsToRebind.Add(child.gameObject);
        }
      }

      // get the current path of the object that the animator is on under the avatar
      string animatorObjectPath = GetGameObjectPath(DSUObject);
      

      // now we need to make a rewrite dictionary to store the old paths and the new paths
      Dictionary<string, string> pathRewrite = new Dictionary<string, string>();

      // for each of the objects to rebind, we need to get the current path and store it in the pathRewrite
      // then we need to prefix that path with the animatorObjectPath and store that as the new path
      foreach (GameObject obj in objectsToRebind)
      {
        // get the current path of the object relative to the animatorObjectPath
        string currentPath = GetGameObjectPath(obj);
        // remove the animatorObjectPath from the start of the currentPath
        currentPath = currentPath.Replace(animatorObjectPath, "");
        // the above line will leave a leading `/` so remove it
        if (currentPath.StartsWith("/"))
        {
          currentPath = currentPath.Substring(1);
        }
        //this should now be the path relative to the animatorObjectPath, which should match up to the animator provided
        // with the prefab to be linked

        // get the object's path relative to the avatar
        string objectPath = GetGameObjectPath(obj);
        // remove the avatarPath from the start of the objectPath
        objectPath = objectPath.Replace(avatarPath, "");
        // remove the starting `/` from the objectPath if it exists
        if (objectPath.StartsWith("/"))
        {
          objectPath = objectPath.Substring(1);
        }

        // store the currentPath and the new path in the pathRewrite
        pathRewrite[currentPath] = objectPath;

      }

      // debug print all the pathRewrite entries in one go
      StringBuilder pathRewriteDebug = new StringBuilder();
      foreach (KeyValuePair<string, string> entry in pathRewrite)
      {
        pathRewriteDebug.Append("Key: ");
        pathRewriteDebug.Append(entry.Key);
        pathRewriteDebug.Append(", Value: ");
        pathRewriteDebug.Append(entry.Value);
        pathRewriteDebug.Append("\n");
      }
      CoreLogDebug("pathRewrite:\n" + pathRewriteDebug.ToString());

      // now we need to go through all the animations and update the paths
      // loop over the dictionary
      foreach (KeyValuePair<string, string> entry in pathRewrite)
      {
        // get the current path and the new path
        string currentPath = entry.Key;
        string newPath = entry.Value;

        // check if the currentPath is the same as the newPath, if it is then skip this entry
        if (currentPath == newPath)
        {
          continue;
        }

        //update the animation clips
        UpdateAnimationClips(avatar.name, currentPath, newPath);
      }
      // that should take care of the animations, for all the mesh items sitting next to the armature
      // now we need to merge the armatures together and rebind the meshes to the new armature

      // get the Animator component from the avatar
      Animator animator = avatar.GetComponent<Animator>();
      // get the HumanBodyBones enum value from the armatureBoneToLinkTo
      HumanBodyBones boneToLinkTo = armatureLinkModule.armatureBoneToLinkTo;
      // get the GameObject of the boneToLinkTo
      GameObject boneToLinkToGameObject = animator.GetBoneTransform(boneToLinkTo).gameObject;

      // now we have the target bone on the avatar, that we are going to merge this onto

      // compare the child bones of the armatureRoot to the child bones of the boneToLinkToGameObject
      // and add any missing bones to the boneToLinkToGameObject
      // this is done by checking the names of the bones and adding any that are missing

      // walk the bones of avatar's armature starting from the parent of the boneToLinkTo and compare
      // to the armatureRoot's children
      Transform[] avatarBones = boneToLinkToGameObject.GetComponentsInChildren<Transform>();
      Transform[] addonBones = armatureRoot.GetComponentsInChildren<Transform>();

      // create a list of the names of the bones in the avatar's armature
      List<string> avatarBoneNames = new List<string>();
      foreach (Transform bone in avatarBones)
      {
        avatarBoneNames.Add(bone.name);
      }

      // create a list of the names of the bones in the addon's armature
      List<BoneData> addonBoneNames = new List<BoneData>();
      foreach (Transform bone in addonBones)
      {
        addonBoneNames.Add(new BoneData { name = bone.name, parentName = bone.parent != null ? bone.parent.name : "" });
      }

      // ensure that any 'bone' in the addonBones list whose name matches that of the armatureRoot is removed
      addonBoneNames.RemoveAll(b => b.name == armatureRoot.name);

      // debug print the armatureRoot name
      CoreLogDebug("armatureRoot.name: " + armatureRoot.name);

      // debug print the addonBoneNames list after removing the armatureRoot
      StringBuilder addonBoneNamesStringBuilder2 = new StringBuilder();
      foreach (BoneData boneData in addonBoneNames)
      {
        addonBoneNamesStringBuilder2.Append("name: " + boneData.name + ", parentName: " + boneData.parentName + "\n");
      }
      CoreLogDebug("addonBoneNames after removing armatureRoot:\n" + addonBoneNamesStringBuilder2.ToString());

      // create a list of the names of the bones in the addon's armature for comparison
      List<string> addonBoneNamesList = addonBoneNames.Select(b => b.name).ToList();

      // create a list of the bones that are in the addon's armature but not in the avatar's armature
      List<string> missingBones = addonBoneNamesList.Except(avatarBoneNames).ToList();

      // create a List of bones that are on both the avatar and the addon 
      //(this is so we can check for differentials in the rotation/position/scale of the bones)
      List<string> commonBones = addonBoneNamesList.Intersect(avatarBoneNames).ToList();

      // print missingBones to console in one block
      StringBuilder missingBonesStringBuilder = new StringBuilder();
      foreach (string missingBone in missingBones)
      {
        missingBonesStringBuilder.Append(missingBone + "\n");
      }
      CoreLogDebug("missingBones:\n" + missingBonesStringBuilder.ToString());

      // list of bones that have been added to the avatar's armature
      List<string> addedBones = new List<string>();

      // list to store bones that have a different rotation/position/scale
      List<string> differentBones = new List<string>();

      // loop over the commonBones and check if the rotation/position/scale of the bones are different
      foreach (string commonBoneName in commonBones)
      {
        // find the bone in the addonBones list
        BoneData commonBone = addonBoneNames.Find(b => b.name == commonBoneName);

        // find the bone in the avatarBones list
        Transform avatarBone = avatarBones.FirstOrDefault(b => b.name == commonBoneName);

        // find the bone in the addonBones list
        Transform addonBone = addonBones.FirstOrDefault(b => b.name == commonBoneName);

        // check if the rotation/position/scale of the bones are different
        if (avatarBone.rotation != addonBone.rotation || avatarBone.position != addonBone.position || avatarBone.localScale != addonBone.localScale)
        {
          // add the bone name to the differentBones list
          differentBones.Add(commonBoneName);
        }
      }

      // if there are any differentBones then log a warning to the console (including the bone names)
      if (differentBones.Count > 0)
      {
        // print differentBones to console in one block
        StringBuilder differentBonesStringBuilder = new StringBuilder();
        foreach (string differentBone in differentBones)
        {
          differentBonesStringBuilder.Append(differentBone + "\n");
        }
        CoreLogError("The following bones have different rotation/position/scale in the addon's armature compared to the avatar's armature:\n" + differentBonesStringBuilder.ToString());
      }

      // get a list of vertices that are affected by the bones that are different
      // this is so we can warn the user that the vertices will not move as expected
      // this is done by getting the skinned mesh renderers that are affected by the bones that are different
      // and then getting the vertices that are affected by those skinned mesh renderers

      // get all the skinned mesh renderers under the DSUObject
      SkinnedMeshRenderer[] skinnedMeshRenderers = DSUObject.GetComponentsInChildren<SkinnedMeshRenderer>(true);

      // debug print the skinnedMeshRenderers in one block
      StringBuilder skinnedMeshRenderersStringBuilder = new StringBuilder();
      foreach (SkinnedMeshRenderer skinnedMeshRenderer in skinnedMeshRenderers)
      {
        skinnedMeshRenderersStringBuilder.Append(skinnedMeshRenderer.name + "\n");
      }
      CoreLogDebug("skinnedMeshRenderers:\n" + skinnedMeshRenderersStringBuilder.ToString());

      // TODO: still need to finish implementing this section
      #region Mesh re-processing
      // loop over the skinned mesh renderers and get the vertices that are affected by the bones that are different
      foreach (SkinnedMeshRenderer skinnedMeshRenderer in skinnedMeshRenderers)
      {
        // get the bones of the skinned mesh renderer
        Transform[] bones = skinnedMeshRenderer.bones;

        // create a new list of bones to store the bones that are different
        List<Transform> differentBonesTransforms = new List<Transform>();

        // loop over the bones and find the bones that are different
        foreach (Transform bone in bones)
        {
          // find the bone in the differentBones list
          if (differentBones.Contains(bone.name))
          {
            // add the bone to the differentBonesTransforms list
            differentBonesTransforms.Add(bone);
          }
        }

        // get the mesh of the skinned mesh renderer
        Mesh mesh = skinnedMeshRenderer.sharedMesh;

        // get the vertices of the mesh
        Vector3[] vertices = mesh.vertices;

        // create a new list of vertices to store the vertices that are affected by the bones that are different
        List<Vector3> affectedVertices = new List<Vector3>();

        // loop over the vertices and find the vertices that are affected by the bones that are different
        foreach (Vector3 vertex in vertices)
        {
          // get the bone weights of the vertex
          BoneWeight[] boneWeights = mesh.boneWeights;

          // loop over the bone weights and find the bone weights that are affected by the bones that are different
          foreach (BoneWeight boneWeight in boneWeights)
          {
            // check if the bone weight is affected by the bones that are different
            if (differentBonesTransforms.Contains(bones[boneWeight.boneIndex0]) ||
                differentBonesTransforms.Contains(bones[boneWeight.boneIndex1]) ||
                differentBonesTransforms.Contains(bones[boneWeight.boneIndex2]) ||
                differentBonesTransforms.Contains(bones[boneWeight.boneIndex3]))
            {
              // add the vertex to the affectedVertices list
              affectedVertices.Add(vertex);
            }
          }
        }

        // if there are any affectedVertices then log a warning to the console (including the number of vertices)
        if (affectedVertices.Count > 0)
        {
          CoreLogError("The following vertices are affected by the bones that have different rotation/position/scale "
                       + " in the addon's armature compared to the avatar's armature, these vertices will not"
                       + " move as expected: " + affectedVertices.Count);
          
          // ok so this is bad news. for some reason or the bones don't match up, and are going to impact the vertices
          // need to make a copy of the mesh at this point so we can try to counteract the issue

          // copy the mesh to a new file
          string meshPath = Constants.ASSETS_MANAGED_FOLDER_GENERATED + avatar.name + "/temp_items/" + skinnedMeshRenderer.name +"_DSU-"+DSUNumber +".asset";
          AssetDatabase.CreateAsset(Object.Instantiate(mesh), meshPath);
          CoreLogDebug("Mesh copied to: " + meshPath);

          // ok so now we have a copy of the mesh, we need to set the skinned mesh renderer to use the new mesh
          skinnedMeshRenderer.sharedMesh = AssetDatabase.LoadAssetAtPath<Mesh>(meshPath);

          // get the new mesh
          mesh = skinnedMeshRenderer.sharedMesh;

          // now we need to update the new mesh to counteract the vertices displacement/rotation/scale

      //     // temp affectedVertices list so we can write to it (as the original is readonly while iterating)
      //     List<Vector3> affectedVerticesTemp = new List<Vector3>(affectedVertices);

      //     // get count of affectedVertices
      //     int affectedVerticesCount = affectedVertices.Count;

      //     // print to console that we are starting to process the affectedVertices
      //     CoreLog("Processing " + affectedVerticesCount + " affected vertices");

      //     // counter to keep track of how many affectedVertices have been processed
      //     int affectedVerticesProcessed = 0;
          
      //     // if the affectedVerticesCount is 0 then there is nothing to do, log a debug to the console and continue
      //     // to the next skinned mesh renderer
      //     if (affectedVerticesCount == 0)
      //     {
      //       // log as a debug to the console
      //       CoreLogDebug("No affected vertices found for skinned mesh renderer");
      //       continue;
      //     }

      //     // loop over the affectedVertices and counteract the displacement/rotation/scale
      //     foreach (Vector3 vertex in affectedVertices)
      //     {
      //       #region Counteract displacement/rotation/scale
      //       // counteract the displacement/rotation/scale

      //       // // console print to say we are processing x of y affected vertices
      //       // CoreLogDebug("Processing affected vertex " + affectedVerticesProcessed + " of " + affectedVerticesCount);
            
      //       // // get the bones linked to the vertex
      //       // List<Transform> bonesLinkedToVertex = new List<Transform>();

      //       // // get the bone weights of the vertex
      //       // BoneWeight[] boneWeights = mesh.boneWeights;

      //       // // get the count of boneweights
      //       // int boneWeightsCount = boneWeights.Length;

      //       // // if the boneWeightsCount is 0 then there is an issue, log an error to the console and continue to the next vertex
      //       // if (boneWeightsCount == 0 || boneWeights == null)
      //       // {
      //       //   // log as a critical error to the console, as this should not happen
      //       //   CoreLogCritical("No bone weights found for vertex");
      //       //   continue;
      //       // }

      //       // // print to console that we are starting to process the bone weights
      //       // CoreLog("Processing " + boneWeightsCount + " bone weights for vertex");

      //       // // counter to keep track of how many boneweights have been processed
      //       // int boneWeightsProcessed = 0;

      //       // // loop over the bone weights and find the bones linked to the vertex
      //       // foreach (BoneWeight boneWeight in boneWeights)
      //       // {
      //       //   // check if the bone weight is linked to the vertex
      //       //   if (vertex == vertices[boneWeight.boneIndex0] ||
      //       //       vertex == vertices[boneWeight.boneIndex1] ||
      //       //       vertex == vertices[boneWeight.boneIndex2] ||
      //       //       vertex == vertices[boneWeight.boneIndex3])
      //       //   {
      //       //     // add the bone to the bonesLinkedToVertex list
      //       //     bonesLinkedToVertex.Add(bones[boneWeight.boneIndex0]);
      //       //     bonesLinkedToVertex.Add(bones[boneWeight.boneIndex1]);
      //       //     bonesLinkedToVertex.Add(bones[boneWeight.boneIndex2]);
      //       //     bonesLinkedToVertex.Add(bones[boneWeight.boneIndex3]);
      //       //   }

      //       //   // increment the boneWeightsProcessed counter
      //       //   boneWeightsProcessed++;

      //       //   // print a debug message to the console if the boneWeightsProcessed showing progress
      //       //   if (boneWeightsProcessed % 1000 == 0)
      //       //   {
      //       //     CoreLogDebug("boneWeightsProcessed: " + boneWeightsProcessed + " of " + boneWeightsCount);
      //       //   }
      //       // }

      // //       // that will be the current set of bones that are linked to the vertex, ie the ones from the addon armature
      // //       // that are different to the avatar armature

      // //       // now we need to find the bones in the avatar armature that are linked to the vertex
            
      // //       // get the bones in the avatar armature that are linked to the vertex
      // //       List<Transform> avatarBonesLinkedToVertex = new List<Transform>();

      // //       // loop over the bonesLinkedToVertex and find the bones in the avatar armature that are linked to the vertex
      // //       foreach (Transform boneLinkedToVertex in bonesLinkedToVertex)
      // //       {
      // //         // find the bone in the avatarBones list
      // //         Transform avatarBoneLinkedToVertex = avatarBones.FirstOrDefault(b => b.name == boneLinkedToVertex.name);

      // //         // if the avatarBoneLinkedToVertex is null then there is an issue, log an error to the console and continue to the next bone
      // //         if (avatarBoneLinkedToVertex == null)
      // //         {
      // //           // log as a critical error to the console, as this should not happen
      // //           CoreLogCritical("Avatar bone not found for: " + boneLinkedToVertex.name);
      // //           continue;
      // //         }

      // //         // add the avatarBoneLinkedToVertex to the avatarBonesLinkedToVertex list
      // //         avatarBonesLinkedToVertex.Add(avatarBoneLinkedToVertex);
      // //       }

      // //       // now we have the bones in the avatar armature that are linked to the vertex, we need to counteract the
      // //       // displacement/rotation/scale issue

      // //       // counteract the displacement/rotation/scale issue
      // //       // this is done by getting the transform differences between the bones in the addon armature and the bones
      // //       // in the avatar armature, then applying those differences to the vertex

      // //       // get the transform differences between the bones in the addon armature and the bones in the avatar armature
      // //       // this is done by getting the position/rotation/scale differences between the bones in the addon armature
      // //       // and the bones in the avatar armature
      // //       // then applying those differences to the vertex

      // //       // loop over the avatarBonesLinkedToVertex and find the transform differences between the bones in the addon
      // //       // armature and the bones in the avatar armature
      // //       foreach (Transform avatarBoneLinkedToVertex in avatarBonesLinkedToVertex)
      // //       {
      // //         // find the bone in the addonBones list
      // //         Transform boneLinkedToVertex = bonesLinkedToVertex.FirstOrDefault(b => b.name == avatarBoneLinkedToVertex.name);

      // //         // if the boneLinkedToVertex is null then there is an issue, log an error to the console and continue to the next bone
      // //         if (boneLinkedToVertex == null)
      // //         {
      // //           // log as a critical error to the console, as this should not happen
      // //           CoreLogCritical("Bone not found for: " + avatarBoneLinkedToVertex.name);
      // //           continue;
      // //         }

      // //         // get the position/rotation/scale differences between the bones in the addon armature and the bones in the avatar armature
      // //         Vector3 positionDifference = boneLinkedToVertex.position - avatarBoneLinkedToVertex.position;
      // //         Quaternion rotationDifference = boneLinkedToVertex.rotation * Quaternion.Inverse(avatarBoneLinkedToVertex.rotation);
      // //         Vector3 scaleDifference = boneLinkedToVertex.localScale - avatarBoneLinkedToVertex.localScale;

      // //         // duplicate the vertex so we can apply the differences to it (as the original is readonly while iterating)
      // //         Vector3 vertexCopy = vertex;

      // //         // apply the position/rotation/scale differences to the vertex
      // //         vertexCopy += positionDifference;
      // //         vertexCopy = rotationDifference * vertexCopy;
      // //         vertexCopy += scaleDifference;

      // //         // add the vertex to the affectedVerticesTemp list
      // //         affectedVerticesTemp.Add(vertexCopy);

      // //       }

      //     // increment the affectedVerticesProcessed counter
      //     affectedVerticesProcessed++;
      //     #endregion
      //     }


      //     // now write the affectedVerticesTemp back to the affectedVertices
      //     affectedVertices = new List<Vector3>(affectedVerticesTemp);

      //     // then we need to update the new mesh with the new vertices
      //     mesh.vertices = affectedVertices.ToArray();
      //     mesh.RecalculateNormals();
      //     mesh.RecalculateBounds();
      //     mesh.RecalculateTangents();

      //     // now mark the mesh as dirty
      //     EditorUtility.SetDirty(mesh);

      //     // then refresh and save the asset database
      //     AssetDatabase.Refresh();
      //     AssetDatabase.SaveAssets();
        }




      }
      #endregion

      
      #region Bone reparenting
      // loop over the missingBones and reparent them into the avatar's armature, note that they must not be moved or scaled
      // from their current position, just reparented
      foreach (string missingBoneName in missingBones)
      {
        // find the bone in the addonBones list
        BoneData missingBone = addonBoneNames.Find(b => b.name == missingBoneName);

        // check if the current missing bone's parent is in the addedBones list, if it is then skip this bone
        if (addedBones.Contains(missingBone.parentName))
        {
          // skipping this bone as the parent is the top of an addon leaf bone tree
          // but we need to put it on the addedBones list so that the next bones down the tree can be handled
          addedBones.Add(missingBoneName);
          // now continue to the next bone
          continue;
        }

        // find the parent bone in the avatarBones list
        Transform parentBone = avatarBones.FirstOrDefault(b => b.name == missingBone.parentName);

        // if the parentBone is null then there is an issue, log an error to the console and continue to the next bone
        if (parentBone == null)
        {
          // log as a critical error to the console, as this should not happen
          // should never get here as all leaf bone trees should have already been filtered out
          CoreLogCritical("Parent bone not found for: " + missingBoneName);
          continue;
        }

        // find the bone in the addonBones list
        Transform bone = addonBones.FirstOrDefault(b => b.name == missingBoneName);

        // reparent the bone to the parentBone
        bone.SetParent(parentBone, true);

        // add the bone name to the addedBones list
        addedBones.Add(missingBoneName);

        // debug log to console that the bone has been reparented
        CoreLogDebug("Bone has been reparented to: " + parentBone.name);
      }
      #endregion
      // now all the bones have been added to the avatar's armature, we need to rebind the skinned mesh renderers
      // to the new armature at the boneToLinkTo
  
      #region Skinned mesh renderer rebind
      //  loop over the skinned mesh renderers and rebind them to the new armature
      foreach (SkinnedMeshRenderer skinnedMeshRendererToRebind in skinnedMeshRenderers)
      {
        // check if skinnedMeshRendererToRebind.bones is null, if it is then there is an issue, log an error to the console and continue to the next skinned mesh renderer
        if (skinnedMeshRendererToRebind.bones == null)
        {
          // log as a critical error to the console, as this should not happen
          CoreLogCritical("Bones not found for skinned mesh renderer : " + skinnedMeshRendererToRebind.name);
        }
        else
        {
          // log as a debug to the console
          CoreLogDebug("Bones found for skinned mesh renderer : " + skinnedMeshRendererToRebind.name);

          // get the bones of the skinned mesh renderer
          Transform[] bonesToRebind = skinnedMeshRendererToRebind.bones;

          // list the bones that are in the skinned mesh renderer in one block
          StringBuilder bonesToRebindStringBuilder = new StringBuilder();
          foreach (Transform boneToRebind in bonesToRebind)
          {
            bonesToRebindStringBuilder.Append(boneToRebind.name + "\n");
          }
          CoreLogDebug("bonesToRebind:\n" + bonesToRebindStringBuilder.ToString());

          // now we need only rebind bones that are common to the avatar and the addon (all the others
          // are already bound to the mesh so no point in messing with them) thus the 'commonBones' list
          // will be of help to filter the bones that need to be rebound (note that its just a list of names,
          // not actual bone refs)

          // create a list of bones to update from the bonesToRebind list that are in the commonBones list
          List<Transform> bonesToUpdate = new List<Transform>();

          // loop over the bonesToRebind and find the bones that are in the commonBones list
          foreach (Transform boneToRebind in bonesToRebind)
          {
            // check if the boneToRebind is in the commonBones list
            if (commonBones.Contains(boneToRebind.name))
            {
              // add the boneToRebind to the bonesToUpdate list
              bonesToUpdate.Add(boneToRebind);
            }
          }

          // print bonesToUpdate to console in one block
          StringBuilder bonesToUpdateStringBuilder = new StringBuilder();
          foreach (Transform boneToUpdate in bonesToUpdate)
          {
            bonesToUpdateStringBuilder.Append(boneToUpdate.name + "\n");
          }
          CoreLogDebug("bonesToUpdate:\n" + bonesToUpdateStringBuilder.ToString());

          // now we have the bones that need to be rebound, we need to rebind them to the new armature

          // loop over the bonesToUpdate and rebind them to the avatar's armature
          for (int i = 0; i < bonesToUpdate.Count; i++)
          {
            // find the bone in the avatarBones list
            Transform newBone = avatarBones.FirstOrDefault(b => b.name == bonesToUpdate[i].name);

            // if the newBone is null then there is an issue, log an error to the console and continue to the next bone
            if (newBone == null)
            {
              // log as a critical error to the console, as this should not happen
              CoreLogCritical("New bone not found for: " + bonesToUpdate[i].name);
              continue;
            }

            // rebind the bone to the newBone
            bonesToUpdate[i] = newBone;

            // debug log to console that the bone has been rebound
            CoreLogDebug("Bone has been rebound to: " + newBone.name);
          }


        
        }

        // even if no bones were found, we still need to rebind the root bone (and that is always there)
        skinnedMeshRendererToRebind.rootBone = boneToLinkToGameObject.transform;

        // check if the Anchor Override is set on the skinned mesh renderer, if it is then set it to the matching bone in the avatar's armature
        if (skinnedMeshRendererToRebind.probeAnchor != null)
        {
          // find the bone in the avatarBones list
          Transform anchorOverride = avatarBones.FirstOrDefault(b => b.name == skinnedMeshRendererToRebind.probeAnchor.name);

          // if the anchorOverride target is null then there is an issue, log an error to the console and continue to the next skinned mesh renderer
          if (anchorOverride == null)
          {
            // log as a critical error to the console, as this should not happen
            CoreLogCritical("Anchor Override target not found for: " + skinnedMeshRendererToRebind.probeAnchor.name);
            continue;
          }

          // set the anchorOverride to the anchorOverride
          skinnedMeshRendererToRebind.probeAnchor = anchorOverride;

          // debug log to console that the skinned mesh renderer has been rebound
          CoreLogDebug("Skinned mesh renderer has been rebound to: " + anchorOverride.name);
        }
        else
        {
          // debug log to console that the skinned mesh renderer has been rebound
          CoreLogDebug("Skinned mesh renderer has been rebound to: " + boneToLinkToGameObject.name);
        }    

        // debug log to console that the skinned mesh renderer has been rebound
        CoreLogDebug("Skinned mesh renderer has been rebound to: " + boneToLinkToGameObject.name);
      }

      #endregion
    
      // TODO: add in a section that takes care of updating the animations to match the new bone structure
      #region Animation rebind
      // from the addonBoneNamesList we can get the bones that are in the addon's armature
      // given that we can use that as half the information we need to rebind the animations
      // the other half is the bones that are in the avatar's armature, we can get that from the avatarBones list
      // so we can loop over the addonBoneNamesList and find the corresponding bone in the avatarBones list
      // then we can update the animation clips to match the new bone structure

     
      #endregion
    
    }
    
    private void performReparentRoot(CVRAvatar avatar, GameObject DSUObject, int DSUNumber, armatureLink armatureLinkModule)
    {
      // Implementation for performReparentRoot
      // console print to say this function is being called
      CoreLog("performReparentRoot() called");

      // call function to add the CVRFuryGameObjectInfoTag to the DSUObject + children
      AddCVRFuryGameObjectInfoTagToAddon(DSUObject, DSUNumber);      

      // get the path to the avatar
      string avatarPath = GetGameObjectPath(avatar.gameObject);

      // get the current path of the addonObjectToLink and store it
      string addonObjectToLinkPath = GetGameObjectPath(armatureLinkModule.addonObjectToLink);

      // remove the avatarPath from the start of the addonObjectToLinkPath
      addonObjectToLinkPath = addonObjectToLinkPath.Replace(avatarPath, "");

      // remove the starting `/` from the addonObjectToLinkPath if it exists
      if (addonObjectToLinkPath.StartsWith("/"))
      {
        addonObjectToLinkPath = addonObjectToLinkPath.Substring(1);
      }

      // move the addonObjectToLink to be a child of the armatureBoneToLinkTo, note armatureBoneToLinkTo is of
      // type HumanBodyBones, the addonObjectToLink is of type GameObject and the addonObjectToLink should not move in
      // scene space but just be parented to the bone (this is so the user can position the object where they want it)

      // get the Animator component from the avatar
      Animator animator = avatar.GetComponent<Animator>();

      // get the HumanBodyBones enum value from the armatureBoneToLinkTo
      HumanBodyBones boneToLinkTo = armatureLinkModule.armatureBoneToLinkTo;

      // get the GameObject of the boneToLinkTo
      GameObject boneToLinkToGameObject = animator.GetBoneTransform(boneToLinkTo).gameObject;

      // perform the reparenting
      armatureLinkModule.addonObjectToLink.transform.SetParent(boneToLinkToGameObject.transform, true);

      // debug log to console that the object has been reparented
      CoreLogDebug("Object has been reparented to: " + boneToLinkToGameObject.name);

      // get the new path of the addonObjectToLink and store it
      string newAddonObjectToLinkPath = GetGameObjectPath(armatureLinkModule.addonObjectToLink);

      // remove the avatarPath from the start of the newAddonObjectToLinkPath
      newAddonObjectToLinkPath = newAddonObjectToLinkPath.Replace(avatarPath, "");

      // remove the starting `/` from the newAddonObjectToLinkPath if it exists
      if (newAddonObjectToLinkPath.StartsWith("/"))
      {
        newAddonObjectToLinkPath = newAddonObjectToLinkPath.Substring(1);
      }

      // check if the path of the addonObjectToLink has changed if it has not then stop here
      if (addonObjectToLinkPath == newAddonObjectToLinkPath)
      {
        // log to console that the object has not moved
        CoreLogDebug("No animation rebind needed as Object has not moved");
        return;
      }

      //update the animation clips
      UpdateAnimationClips(avatar.name, addonObjectToLinkPath, newAddonObjectToLinkPath);
    }


    #region Helper Functions/structs
    public void AddCVRFuryGameObjectInfoTagToAddon(GameObject DSUObject, int DSUNumber)
    {
      // check if the DSUObject has a CVRFuryDataStorageUnit component, if it does not then return
      if (DSUObject.GetComponent<CVRFuryDataStorageUnit>() == null)
      {
        CoreLogError("DSUObject does not have a CVRFuryDataStorageUnit component, cannot add CVRFuryGameObjectInfoTag");
        return;
      }

      // get the prefabName from the DSU component of the DSUObject
      string prefabName = DSUObject.GetComponent<CVRFuryDataStorageUnit>().prefabName;

      // check if the prefabName is null or empty, if it is then return
      if (string.IsNullOrEmpty(prefabName))
      {
        CoreLogError("prefabName is null or empty, cannot add CVRFuryGameObjectInfoTag");
        return;
      }

      // debug log to console the prefabName
      CoreLogDebug("prefabName: " + prefabName);

      // get the list of all children of the DSUObject
      List<GameObject> children = DSUObject.GetAllChildGameObjects();
      
      // loop over the children of the DSUObject and add the CVRFuryGameObjectInfoTag component to each child
      foreach (GameObject child in children)
      {
        // check if the child has a CVRFuryGameObjectInfoTag component, if it does not then add it
        if (child.GetComponent<CVRFuryGameObjectInfoTag>() == null)
        {
          child.AddComponent<CVRFuryGameObjectInfoTag>();
        }

        // get the CVRFuryGameObjectInfoTag component from the child
        CVRFuryGameObjectInfoTag CVRFuryGameObjectInfoTag = child.GetComponent<CVRFuryGameObjectInfoTag>();

        // set the sourcePrefabName on the CVRFuryGameObjectInfoTag component
        CVRFuryGameObjectInfoTag.sourcePrefabName = prefabName;

        // set the DSUNumber on the CVRFuryGameObjectInfoTag component
        CVRFuryGameObjectInfoTag.sourceDSUNumber = DSUNumber;
      }

      // add the CVRFuryGameObjectInfoTag component to the DSUObject
      if (DSUObject.GetComponent<CVRFuryGameObjectInfoTag>() == null)
      {
        DSUObject.AddComponent<CVRFuryGameObjectInfoTag>();
      }
      // set the sourcePrefabName on the CVRFuryGameObjectInfoTag component
      DSUObject.GetComponent<CVRFuryGameObjectInfoTag>().sourcePrefabName = prefabName;

      // set the DSUNumber on the CVRFuryGameObjectInfoTag component
      DSUObject.GetComponent<CVRFuryGameObjectInfoTag>().sourceDSUNumber = DSUNumber;


    }

    public void UpdateAnimationClips(string avatarName, string addonObjectToLinkPath, string newAddonObjectToLinkPath)
    {
      string animationClipsFolder = Constants.ASSETS_MANAGED_FOLDER_GENERATED + avatarName + "/temp_items";

      if (!Directory.Exists(animationClipsFolder))
      {
        CoreLogError("Animation clips folder does not exist: " + animationClipsFolder);
        return;
      }

      CoreLogDebug("Animation clips folder: " + animationClipsFolder);

      foreach (string animationClipPath in Directory.GetFiles(animationClipsFolder))
      {
        if (!File.Exists(animationClipPath))
        {
          CoreLogCritical("File does not exist: " + animationClipPath);
          continue;
        }

        if (!animationClipPath.EndsWith(".anim"))
        {
          continue;
        }

        CoreLogDebug("addonObjectToLinkPath: " + addonObjectToLinkPath);
        CoreLogDebug("newAddonObjectToLinkPath: " + newAddonObjectToLinkPath);

        AnimationClip clip = AssetDatabase.LoadAssetAtPath<AnimationClip>(animationClipPath);
        EditorCurveBinding[] curveBindings = AnimationUtility.GetCurveBindings(clip);

        foreach (EditorCurveBinding curveBinding in curveBindings)
        {
          CoreLogDebug("Current curveBinding.path: " + curveBinding.path);

          if (curveBinding.path == addonObjectToLinkPath)
          {
            EditorCurveBinding newCurveBinding = new EditorCurveBinding
            {
              path = newAddonObjectToLinkPath,
              type = curveBinding.type,
              propertyName = curveBinding.propertyName
            };

            AnimationCurve curve = AnimationUtility.GetEditorCurve(clip, curveBinding);
            AnimationUtility.SetEditorCurve(clip, curveBinding, null);
            AnimationUtility.SetEditorCurve(clip, newCurveBinding, curve);
          }
        }

        AssetDatabase.SaveAssets();
        EditorUtility.SetDirty(clip);
        AssetDatabase.Refresh();
      }
    }

        // struct to store bone data (name and parent name)
    public struct BoneData
    {
      public string name;
      public string parentName;
    }
    #endregion

  }
}
// #endif
