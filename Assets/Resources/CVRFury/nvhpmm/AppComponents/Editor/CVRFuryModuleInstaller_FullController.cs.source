// { "version": "0.3.6" , "canInstall": true , "optional": true , "defineSymbolSuffix": "_MI_FC", dependencies: []}
// #if UNITY_EDITOR && CVR_CCK_EXISTS

using Math = System.Math;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System.IO;
using UnityEditor;
using UnityEditor.Animations;
using UnityEditor.UIElements;
using UnityEngine;
using UnityEngine.UIElements;
using UnityEngine.SceneManagement;
using uk.novavoidhowl.dev.cvrfury.runtime;
using ABI.CCK.Scripts.Editor;
using ABI.CCK.Scripts;
using ABI.CCK.Components;
using Constants = uk.novavoidhowl.dev.cvrfury.packagecore.Constants;
using static uk.novavoidhowl.dev.cvrfury.packagecore.CoreUtils;
using static uk.novavoidhowl.dev.cvrfury.deployable.ReportBuilderSupport;
using static uk.novavoidhowl.dev.cvrfury.supporting_classes.editor.Animation;
using static uk.novavoidhowl.dev.cvrfury.supporting_classes.runtime.General;

// temp using for testing
using System.Text;

/// <summary>
/// fullController Module
/// this is handles avatar controller/config (menus, animators etc.) just before upload/play
/// </summary>

namespace uk.novavoidhowl.dev.cvrfury.deployable
{
  public class fullControllerModuleProcessor : IModuleProcessor
  {
    public void ProcessModule(CVRFuryModule module, GameObject targetAvatar, int DSUNumber, GameObject DSUObject)
    {
      // Implementation for fullControllerModuleProcessor
      // console print to say this function is being called
      CoreLog("fullControllerModuleProcessor.ProcessModule() called");

      // log the module's moduleType to the console
      CoreLog("module.ModuleType: " + module.ModuleType);

      // access the CVRAvatar component on the targetAvatar
      CVRAvatar avatar = targetAvatar.GetComponent<CVRAvatar>();

      // check if the avatar exists
      if (avatar != null)
      {
        // we have the avatar, and it is valid, also we have a FullController type Module
        // so we need to ensure that 'advanced avatar settings' is enabled on the avatar
        avatar.avatarUsesAdvancedSettings = true;

        // get the avatarSettings from the avatar
        CVRAdvancedAvatarSettings advancedAvatarSettings = avatar.avatarSettings;

        // get the list of menu stores from the avatarSettings (settings public variable)
        List<CVRAdvancedSettingsEntry> CVRAdvancedAvatarMenuList = advancedAvatarSettings.settings;

        // create a temp over all parameter rewrite list (<string, string>)
        Dictionary<string, string> perModuleParametersPairToRename = null;

        // section to handle CVR Fury Controllers
        // check and see if the module has any controllers
        if ((module as fullControllerModule).controllers.Count > 0)
        {
          //// path vars section

          // create a folder in the project to store the generated controller
          // this is based on Constants.ASSETS_MANAGED_FOLDER_GENERATED + AvatarName
          string generatedItemsFolder = Constants.ASSETS_MANAGED_FOLDER_GENERATED + avatar.name;

          if (!Directory.Exists(generatedItemsFolder))
          {
            Directory.CreateDirectory(generatedItemsFolder);
          }

          //// file paths for the generated controllers/locks etc.

          // create path for temp items
          string tempItemsPath = generatedItemsFolder + "/temp_items/DSU-" + DSUNumber;

          // ensure the temp items folder exists
          if (!Directory.Exists(tempItemsPath))
          {
            Directory.CreateDirectory(tempItemsPath);
          }

          // create a new override controller file path based on the generatedItemsFolder
          // called 'overrides_controller_'avatar.name
          string overrideControllerPath =
            generatedItemsFolder + "/overrides_controller_" + avatar.name + ".overrideController";

          // create a new animator controller file path based on the generatedItemsFolder
          // called 'final_controller_'avatar.name
          string finalControllerPath = generatedItemsFolder + "/final_controller_" + avatar.name + ".controller";

          // create animatorProcessing lock file path based on the generatedItemsFolder called 'processing.lock'
          string processingLockPath = generatedItemsFolder + "/processing.lock";

          // create baseControllerImport lock file path based on the generatedItemsFolder
          // called 'baseControllerImport.lock'
          string baseControllerImportLockPath = generatedItemsFolder + "/baseControllerImport.lock";

          // create build report file path based on the generatedItemsFolder called 'build_report.txt'
          string buildReportPath =
            generatedItemsFolder + "/" + module.ModuleType + "_build_report_" + module.name + ".txt";

          // call the report init function if the build report file doesn't exist
          if (!File.Exists(buildReportPath))
          {
            // call the report init function
            ReportInit(buildReportPath, avatar, module);
          }

          // loop through the controllers in the module
          foreach (RuntimeAnimatorController controller in (module as fullControllerModule).controllers)
          {
            // log the controller's name to the console
            CoreLog("controller.name: " + controller.name);
            ReportAddLine(buildReportPath, "controller.name: " + controller.name);
            ReportAddBlankLine(buildReportPath);

            // get the baseController from the avatarSettings
            RuntimeAnimatorController baseController = advancedAvatarSettings.baseController;

            #region baseController validation
            // check if baseController don't exist
            if (baseController == null)
            {
              // if they don't, log an error to the console
              CoreLogError("No base controller found, restoring defaults");
              ReportAddErrorLine(buildReportPath, "No base controller found, restoring defaults");
              // set the  the CCK default animator controller to the controller file at path
              // /Assets/ABI.CCK/Animations/AvatarAnimator.controller
              advancedAvatarSettings.baseController = AssetDatabase.LoadAssetAtPath<AnimatorController>(
                "Assets/ABI.CCK/Animations/AvatarAnimator.controller"
              );
            }
            #endregion
            // so we now have a baseController we can build upon should there not be any built ones

            #region processing flow logic
            // check the lock file to see if controller processing is in progress
            // if it is, we already have a controller in progress from this and can add to it
            // if it isn't, then what we have is the old controller and we need to start fresh

            //vars to hold the controller/override files
            AnimatorOverrideController CVRFuryOverrides;
            AnimatorController CVRFuryFinalController;

            // check if the processing lock file exists
            if (File.Exists(processingLockPath))
            {
              //console print to say we are continuing with controller processing
              CoreLog("Continuing with controller processing");
              ReportAddBlankLine(buildReportPath);
              ReportAddLine(buildReportPath, "Continuing with controller processing");

              // currently exists so there should be a controller set in progress so load them
              // load the override controller file
              CVRFuryOverrides = AssetDatabase.LoadAssetAtPath<AnimatorOverrideController>(overrideControllerPath);

              // load the animator controller file
              CVRFuryFinalController = AssetDatabase.LoadAssetAtPath<AnimatorController>(finalControllerPath);
            }
            else
            {
              //console print to say we are starting fresh
              CoreLog("New processing run creating fresh controllers");
              ReportAddBlankLine(buildReportPath);
              ReportAddLine(buildReportPath, "New processing run creating fresh controllers");

              // no lock file so we need to start fresh
              // get rid of any existing controller/import lock files
              AssetDatabase.DeleteAsset(overrideControllerPath);
              AssetDatabase.DeleteAsset(finalControllerPath);
              AssetDatabase.DeleteAsset(baseControllerImportLockPath);
              // refresh the asset database
              AssetDatabase.Refresh();

              // create the override file
              AssetDatabase.CreateAsset(new AnimatorOverrideController(), overrideControllerPath);

              // load the override controller file
              CVRFuryOverrides = AssetDatabase.LoadAssetAtPath<AnimatorOverrideController>(overrideControllerPath);

              // create the controller file
              AssetDatabase.CreateAsset(new AnimatorController(), finalControllerPath);

              // load the animator controller file
              CVRFuryFinalController = AssetDatabase.LoadAssetAtPath<AnimatorController>(finalControllerPath);

              // create the lock file
              File.WriteAllText(processingLockPath, string.Empty);
              // finalise assets writes
              AssetDatabase.SaveAssets();
              AssetDatabase.Refresh();
            }

            #endregion
            // at this point we have the override controller and the final controller loaded

            // link the final controller to the overrides
            CVRFuryOverrides.runtimeAnimatorController = CVRFuryFinalController;

            #region baseController import logic
            // check to see if the baseControllerImport lock file exists
            if (!File.Exists(baseControllerImportLockPath))
            {
              // if it doesn't, we need to import the base controller/user's controller
              // set the baseControllerImport lock file
              File.WriteAllText(baseControllerImportLockPath, string.Empty);

              // load the animator from the advancedAvatarSettings
              AnimatorController userAnimator = advancedAvatarSettings.animator;

              // load the overrides from the advancedAvatarSettings
              AnimatorOverrideController userOverrides = advancedAvatarSettings.overrides;

              ReportAddLine(buildReportPath, "Importing base controller");
              // now if the user already has an animator and overrides we need to use those as a base,
              // if not we use the base controller
              if (userAnimator != null)
              {
                // print to console that user controller is being used
                CoreLog("Using current AAS controller as base controller");
                ReportAddLine(buildReportPath, "Using current AAS controller as base controller");

                // input will be - userAnimator
                // target will be - CVRFuryFinalController
                // no need to change any parameters, as this is the first import
                // direct write to the target controller (CVRFuryFinalController)
                AnimatorCloner.MergeControllers(CVRFuryFinalController, userAnimator, null, false);

                // debug print that the merge was successful (TODO: remove this debug print)
                CoreLog("Merge successful");
              }
              else
              {
                // print to console that base controller is being used
                CoreLog("Using base controller as user controller is null");
                ReportAddLine(buildReportPath, "Using base controller as user controller is null");
                // Cast the baseController to AnimatorController
                AnimatorController baseAnimatorController = baseController as AnimatorController;

                if (baseAnimatorController != null)
                {
                  // input will be - baseAnimatorController
                  // target will be - CVRFuryFinalController
                  // no need to change any parameters, as this is the first import
                  // direct write to the target controller (CVRFuryFinalController)
                  AnimatorCloner.MergeControllers(CVRFuryFinalController, baseAnimatorController, null, false);

                  // debug print that the merge was successful (TODO: remove this debug print)
                  CoreLog("Merge successful");
                }
                else
                {
                  // Handle the case where baseController could not be cast to AnimatorController
                  CoreLogError("baseController is not an AnimatorController");
                  ReportAddErrorLine(buildReportPath, "[CRITICAL]: baseController is not an AnimatorController");
                }
              }
            }

            #endregion
            // ok so at this point we should have everything from the base controller in the final controller
            // along with any previous module's additions (we only import the base once, hence the lock file)
            // so now we need to add bits the current controller we are processing


            // get the controller
            AnimatorController sourceAnimatorController = controller as AnimatorController;

            //check if the sourceAnimatorController is null
            if (sourceAnimatorController == null)
            {
              // if it is, log an error to the console
              CoreLogError("sourceAnimatorController is null");
              ReportAddErrorLine(buildReportPath, "[CRITICAL]: sourceAnimatorController is null");
            }
            else
            {
              // ok so that means we should have a valid sourceAnimatorController (not null)

              // debug print the sourceAnimatorController's name
              CoreLog("sourceAnimatorController.name: " + sourceAnimatorController.name);

              // debug print to say global parameters are being processed
              CoreLog("Processing global parameters");

              // get the list of global parameters from the module
              List<string> globalParams = getGlobalParameters(module);

              // debug print to say global parameters are being processed
              CoreLogDebug("Processing global parameters - de-duped list made");
              CoreLogDebug("Processing global parameters - count: " + globalParams.Count);

              // debug print all global parameters in one debug console print
              StringBuilder globalParamsDebug = new StringBuilder();
              foreach (string param in globalParams)
              {
                globalParamsDebug.Append(param + "\n");
              }
              CoreLogDebug("globalParams: \n" + globalParamsDebug.ToString());

              // get the list of parameter names from the sourceAnimatorController
              List<string> sourceParameters = new List<string>(sourceAnimatorController.parameters.Select(p => p.name));

              // debug print to say parameters list acquired from sourceAnimatorController
              CoreLog("Processing parameters - source parameter name list made - count: " + sourceParameters.Count);

              // temp list to hold the parameters that need re-naming (assuming structure is oldName -> newName)
              Dictionary<string, string> parametersPairToRename = null;

              // check if the sourceParameters list is not empty
              if (sourceParameters.Count > 0)
              {
                // loop through the source parameters and if they are not global add them to the parametersPairToRename list
                foreach (string parameter in sourceParameters)
                {
                  // check if the parameter is not global
                  if (!globalParams.Contains(parameter))
                  {
                    if (parametersPairToRename == null)
                    {
                      // init the parametersPairToRename list
                      parametersPairToRename = new Dictionary<string, string>();
                    }
                    if (perModuleParametersPairToRename == null)
                    {
                      // init the perModuleParametersPairToRename list
                      perModuleParametersPairToRename = new Dictionary<string, string>();
                    }
                    // new name string
                    string newParameterName = "[CVRFury_" + DSUNumber + "]_" + parameter;
                    // add the parameter to the parametersPairToRename list
                    parametersPairToRename.Add(parameter, newParameterName);
                    // add the parameter to the perModuleParametersPairToRename list
                    perModuleParametersPairToRename.Add(parameter, newParameterName);
                  }
                  else
                  {
                    // debug print the parameter name (TODO: remove this debug print)
                    CoreLog("parameter is global: " + parameter);
                  }
                }
              }

              if (parametersPairToRename != null)
              {
                // debug print the parametersPairToRename entries all in one debug console print
                StringBuilder parametersPairToRenameDebug = new StringBuilder();
                foreach (KeyValuePair<string, string> pair in parametersPairToRename)
                {
                  parametersPairToRenameDebug.Append(pair.Key + " -> " + pair.Value + "\n");
                }
                CoreLog("parametersPairToRename List: \n" + parametersPairToRenameDebug.ToString());
              }

              // log the controller's name to the console and build report
              CoreLog("animatorController.name: " + sourceAnimatorController.name);
              ReportAddLine(buildReportPath, "animatorController.name: " + sourceAnimatorController.name);
              ReportAddBlankLine(buildReportPath);

              // make a ephemeral copy of the source controller
              // this is to ensure that the source controller is not modified
              // this is a deep copy of the source controller

              // create GUID
              System.Guid tempSourceControllerGUID = System.Guid.NewGuid();

              // path of temp the source controller
              string tempSourceControllerPath =
                tempItemsPath + "/temp_source_controller_" + tempSourceControllerGUID + ".controller";

              // get path of the source controller
              string sourceControllerPath = AssetDatabase.GetAssetPath(sourceAnimatorController);

              // copy the source controller to the temp source controller
              AssetDatabase.CopyAsset(sourceControllerPath, tempSourceControllerPath);

              // load the temp source controller
              AnimatorController tempSourceAnimatorController = AssetDatabase.LoadAssetAtPath<AnimatorController>(
                tempSourceControllerPath
              );

              #region get DSU location info
              // get the hierarchy path of the DSUObject under the targetAvatar
              string DSUObjectPath = GetHierarchyPath(targetAvatar, DSUObject);

              // remove the name of the targetAvatar from the start of the DSUObjectPath so it is relative
              DSUObjectPath = DSUObjectPath.Substring(targetAvatar.name.Length + 1);
              #endregion

              // section to handle manual clip curve path rewrites
              #region rebind animation clips - Manual
              // this has to happen before prefab related rebinds, as it is intended to be used for
              // to get edit animation clip paths to match the prefab base

              // debug print to say we are rebinding animation clips
              CoreLog("Rebinding animation clips - Manual");

              // check and see if the module has any binding rewrites
              if ((module as fullControllerModule).rewriteBindings.Count > 0)
              {
                // loop through the binding rewrites in the module
                foreach (fullControllerModule.BindingRewrite rewrite in (module as fullControllerModule).rewriteBindings)
                {
                  // log the binding rewrite's name to the console
                  CoreLog(
                    "rewrite.from: "
                      + rewrite.from
                      + "\n rewrite.to: "
                      + rewrite.to
                      + "\n rewrite.delete: "
                      + rewrite.delete
                  );

                  // get the animation clips from the source controller
                  AnimationClip[] sourceClips = tempSourceAnimatorController.animationClips;

                  // loop through the layers
                  for (int i = 0; i < tempSourceAnimatorController.layers.Length; i++)
                  {
                    var layer = tempSourceAnimatorController.layers[i];
                    var stateMachine = layer.stateMachine;

                    // loop through the states
                    for (int j = 0; j < stateMachine.states.Length; j++)
                    {
                      var state = stateMachine.states[j].state;

                      // check if the state's motion is a blend tree
                      if (state.motion is BlendTree blendTree)
                      {
                        // get the clips from the blend tree
                        var blendTreeClips = GetClipsFromBlendTree(blendTree);

                        // add the clips to the source clips
                        sourceClips = sourceClips.Concat(blendTreeClips).ToArray();
                      }
                      else if (state.motion is AnimationClip clip)
                      {
                        // add the clip to the source clips
                        sourceClips = sourceClips.Append(clip).ToArray();
                      }
                    }
                  }

                  // loop through the animation clips
                  foreach (AnimationClip clip in sourceClips)
                  {
                    // get the clip's path
                    string clipPath = AssetDatabase.GetAssetPath(clip);

                    //get the filename of the clip, excluding the path and extension
                    string clipFileName = Path.GetFileNameWithoutExtension(clipPath);

                    // generate a guid for the temp clip
                    System.Guid tempClipGUID = System.Guid.NewGuid();

                    // generate a temp clip path
                    string tempClipPath =
                      tempItemsPath + "/" + clipFileName + "_clip_gen_pre_" + tempClipGUID + ".anim";

                    // copy the clip to the temp clip
                    AssetDatabase.CopyAsset(clipPath, tempClipPath);

                    // load the temp clip
                    AnimationClip tempClip = AssetDatabase.LoadAssetAtPath<AnimationClip>(tempClipPath);

                    // loop through the layers
                    for (int i = 0; i < tempSourceAnimatorController.layers.Length; i++)
                    {
                      var layer = tempSourceAnimatorController.layers[i];
                      var stateMachine = layer.stateMachine;

                      // loop through the states
                      for (int j = 0; j < stateMachine.states.Length; j++)
                      {
                        var state = stateMachine.states[j].state;

                        // if the state's motion is the original clip, replace it with the temp clip
                        if (state.motion == clip)
                        {
                          if (rewrite.delete)
                          {
                            rewrite.to = "";
                          }

                          // use the rewriteAnimationClipCurvePaths function to rewrite the animation clip curve paths
                          tempClip = rewriteAnimationClipCurvePaths(tempClip, rewrite.from, rewrite.to);

                          // mark the tempClip as dirty
                          EditorUtility.SetDirty(tempClip);

                          // set the file path as dirty
                          AssetDatabase.WriteImportSettingsIfDirty(tempClipPath);

                          // save the temp clip
                          AssetDatabase.SaveAssets();

                          state.motion = tempClip;
                        }
                        // if the state's motion is a blend tree, check its children
                        else if (state.motion is BlendTree blendTree)
                        {
                          ReplaceClipInBlendTree(blendTree, clip, tempClip, tempClipPath, rewrite);
                        }
                      }
                    }

                    // save the temp source controller
                    AssetDatabase.SaveAssets();
                    
                  }
                }
                // refresh the asset database after all the clips have been processed
                AssetDatabase.Refresh();
              }
              #endregion


              #region rebind animation clips - Prefab Instance
              // rebind prefab name to current name in hierarchy, this needs to be done so that the created animation
              // clips link correctly to the prefab instances

              // debug print to say we are re-binding animation clips
              CoreLog("Rebinding animation clips - Prefab Instance");

              // Try to get the PrefabName from the CVRFuryDataStorageUnit component on the DSUObject
              string FuryPrefabName = DSUObject.GetComponent<CVRFuryDataStorageUnit>().prefabName;

              // check if the FuryPrefabName is null or empty
              if (string.IsNullOrEmpty(FuryPrefabName))
              {
                // if it is, log an error to the console
                CoreLogCritical(
                  "PrefabName is null or empty, please ensure the DSUObject at "
                  + DSUObjectPath
                  + " has a valid prefabName"
                );
                ReportAddErrorLine(buildReportPath, "[CRITICAL]: FuryPrefabName is null or empty");
              }
              else
              {
                // get the animation clips from the source controller
                AnimationClip[] sourceClips = tempSourceAnimatorController.animationClips;

                // loop through the layers
                for (int i = 0; i < tempSourceAnimatorController.layers.Length; i++)
                {
                  var layer = tempSourceAnimatorController.layers[i];
                  var stateMachine = layer.stateMachine;

                  // loop through the states
                  for (int j = 0; j < stateMachine.states.Length; j++)
                  {
                    var state = stateMachine.states[j].state;

                    // check if the state's motion is a blend tree
                    if (state.motion is BlendTree blendTree)
                    {
                      // get the clips from the blend tree
                      var blendTreeClips = GetClipsFromBlendTree(blendTree);

                      // add the clips to the source clips
                      sourceClips = sourceClips.Concat(blendTreeClips).ToArray();
                    }
                    else if (state.motion is AnimationClip clip)
                    {
                      // add the clip to the source clips
                      sourceClips = sourceClips.Append(clip).ToArray();
                    }
                  }
                }

                // loop through the animation clips
                foreach (AnimationClip clip in sourceClips)
                {
                  // get the clip's path
                  string clipPath = AssetDatabase.GetAssetPath(clip);

                  //get the filename of the clip, excluding the path and extension
                  string clipFileName = Path.GetFileNameWithoutExtension(clipPath);

                  // generate a guid for the temp clip
                  System.Guid tempClipGUID = System.Guid.NewGuid();

                  // if the clipFileName has '_clip_gen_pre_' in it then remove all the text from that point onwards
                  if (clipFileName.Contains("_clip_gen_pre_"))
                  {
                    clipFileName = clipFileName.Substring(0, clipFileName.IndexOf("_clip_gen_pre_"));
                  }

                  // generate a temp clip path
                  string tempClipPath = tempItemsPath + "/" + clipFileName + "_clip_gen_" + tempClipGUID + ".anim";

                  // copy the clip to the temp clip
                  AssetDatabase.CopyAsset(clipPath, tempClipPath);

                  // load the temp clip
                  AnimationClip tempClip = AssetDatabase.LoadAssetAtPath<AnimationClip>(tempClipPath);

                  // loop through the layers
                  for (int i = 0; i < tempSourceAnimatorController.layers.Length; i++)
                  {
                    var layer = tempSourceAnimatorController.layers[i];
                    var stateMachine = layer.stateMachine;

                    // loop through the states
                    for (int j = 0; j < stateMachine.states.Length; j++)
                    {
                      var state = stateMachine.states[j].state;

                      // if the state's motion is the original clip, replace it with the temp clip
                      if (state.motion == clip)
                      {
                        // check if the FuryPrefabName and the DSUObjectPath match (if they do, we don't need to rewrite the paths)
                        if (FuryPrefabName != DSUObjectPath)
                        {
                          // use the rewriteAnimationClipCurvePaths function to rewrite the animation clip curve paths
                          tempClip = rewriteAnimationClipCurvePaths(tempClip, FuryPrefabName, DSUObjectPath);

                          // mark the tempClip as dirty
                          EditorUtility.SetDirty(tempClip);

                          // set the file path as dirty
                          AssetDatabase.WriteImportSettingsIfDirty(tempClipPath);

                          // save the temp clip
                          AssetDatabase.SaveAssets();
                        }

                        state.motion = tempClip;
                      }
                      // if the state's motion is a blend tree, check its children
                      else if (state.motion is BlendTree blendTree)
                      {
                        ReplaceClipInBlendTree(blendTree, clip, tempClip, tempClipPath, new fullControllerModule.BindingRewrite { from = FuryPrefabName, to = DSUObjectPath });
                      }
                    }
                  }

                  // save the temp source controller
                  AssetDatabase.SaveAssets();
                }

                // refresh the asset database after all the clips have been processed
                AssetDatabase.Refresh();
              }

              #endregion


              // merge the source into the final controller, renaming the parameters that are not global
              // again direct merge to the target controller (CVRFuryFinalController)
              AnimatorCloner.MergeControllers(
                CVRFuryFinalController,
                tempSourceAnimatorController,
                parametersPairToRename,
                false
              );

              // at this point we need to set the animator and overrides in the advancedAvatarSettings
              // so that they can be used in the next module (additive process)

              // set the animator in the advancedAvatarSettings
              advancedAvatarSettings.animator = CVRFuryFinalController;

              // set the overrides in the advancedAvatarSettings
              advancedAvatarSettings.overrides = CVRFuryOverrides;

              // set the core Overrides in the avatar
              avatar.overrides = CVRFuryOverrides;

              // report that the controller has been processed
              ReportAddLine(buildReportPath, "Controller processed");

              // null the temp controller
              sourceAnimatorController = null;

              // notes: under advancedAvatarSettings there are the following public variables
              // settings: List<CVRAdvancedSettingsEntry> - list of settings for the avatar
              // animator: Animator - the final animator for the avatar (after compiling all layers etc)
              // overrides: AnimatorOverrideController - the overrides for the avatar animator above
              // baseController: RuntimeAnimatorController - the base controller for the avatar
              // baseOverrideController: RuntimeAnimatorController - the base override controller for the avatar
              //                         ref baseController
              // the base ones are used as input for the final animator to be built atop
            }
          }

          // end the report
          ReportEnd(buildReportPath);
        }

        // section to handle CVR Fury Menu Store
        // check and see if the module has any menus
        if ((module as fullControllerModule).menus.Count > 0)
        {
          // check if the perModuleParametersPairToRename is null and if so init it
          if (perModuleParametersPairToRename == null)
          {
            CoreLogDebug("perModuleParametersPairToRename is null, init now");
            perModuleParametersPairToRename = new Dictionary<string, string>();
          }

          // loop through the menus in the module
          foreach (fullControllerModule.MenuEntry menuEntry in (module as fullControllerModule).menus)
          {
            // log the menu's name to the console
            CoreLog("menuEntry.menu.name: " + menuEntry.menu.name);

            // get the menu's prefix
            string prefix = menuEntry.prefix;

            // if the prefix is not null or empty add a forward slash to the end if there is not already one
            if (!string.IsNullOrEmpty(prefix) && !prefix.EndsWith("/"))
            {
              prefix += "/";
            }

            if (!menuEntry.forcePrefixStringFormat)
            {
              // force all backslashes to forward slashes in the prefix
              // this is to ensure that the menu structure is correctly formatted
              // for DakyModsCVR's ActionMenu mod (if the user has it installed)
              // ref https://github.com/dakyneko/DakyModsCVR/tree/master/ActionMenu
              prefix = prefix.Replace("\\", "/");
            }

            // load the menu file from the menuEntry
            CVRFuryMenuStore menu = menuEntry.menu;

            // check if the menu exists
            if (menu != null)
            {
              // now we can access the menu's properties
              // load the menu's menuItems
              List<menuParameter> menuItems = menu.menuItems;

              // loop through the menuItems
              foreach (menuParameter menuItem in menuItems)
              {
                // case statement to handle the different types of menu items
                switch (menuItem.MenuParameterType)
                {
                  case "toggleParameter":
                    // cast the menuItem to a toggleParameter
                    toggleParameter toggleParam = menuItem as toggleParameter;
                    // call the ProcessToggleParameter function to handle the toggle parameter
                    ProcessToggleParameter(
                      toggleParam,
                      prefix,
                      CVRAdvancedAvatarMenuList,
                      perModuleParametersPairToRename
                    );

                    break;

                  case "dropdownParameter":
                    // cast the menuItem to a dropdownParameter
                    dropdownParameter dropdownParam = menuItem as dropdownParameter;
                    // call the ProcessDropdownParameter function to handle the dropdown parameter
                    ProcessDropdownParameter(
                      dropdownParam,
                      prefix,
                      CVRAdvancedAvatarMenuList,
                      perModuleParametersPairToRename
                    );

                    break;

                  case "sliderParameter":
                    // cast the menuItem to a sliderParameter
                    sliderParameter sliderParam = menuItem as sliderParameter;
                    // call the ProcessSliderParameter function to handle the slider parameter
                    ProcessSliderParameter(
                      sliderParam,
                      prefix,
                      CVRAdvancedAvatarMenuList,
                      perModuleParametersPairToRename
                    );

                    break;

                  case "twoDJoystickParameter":
                    // cast the menuItem to a twoDJoystickParameter
                    twoDJoystickParameter twoDJoystickParam = menuItem as twoDJoystickParameter;
                    // call the ProcessTwoDJoystickParameter function to handle the twoDJoystick parameter
                    ProcessTwoDJoystickParameter(
                      twoDJoystickParam,
                      prefix,
                      CVRAdvancedAvatarMenuList,
                      perModuleParametersPairToRename
                    );

                    break;

                  case "threeDJoystickParameter":
                    // cast the menuItem to a threeDJoystickParameter
                    threeDJoystickParameter threeDJoystickParam = menuItem as threeDJoystickParameter;
                    // call the ProcessThreeDJoystickParameter function to handle the threeDJoystick parameter
                    ProcessThreeDJoystickParameter(
                      threeDJoystickParam,
                      prefix,
                      CVRAdvancedAvatarMenuList,
                      perModuleParametersPairToRename
                    );

                    break;

                  default:
                    // if the menuItem is not valid, log an error to the console
                    CoreLogError("Unknown menu item type: " + menuItem.MenuParameterType);
                    break;
                }
              }
            }
          }
        }

        // not sure if this part is needed, but leaving it in for now
        // TODO: // section to handel CVR Fury Parameters
        #region Parameters store
        // check and see if the module has any parameters
        // if ((module as fullControllerModule).parameters.Count > 0)
        // {
        //   // loop through the parameters in the module
        //   foreach (fullControllerModule.ParamsEntry paramEntry in (module as fullControllerModule).parameters)
        //   {
        //     // log the parameter's name to the console
        //     CoreLog("paramEntry.parameters.name: " + paramEntry.parameters.name);

        //     // TODO
        //   }
        // }
        #endregion

        // no smoothing logic for now, may be better to point people to the BTKS for this
        // https://github.com/ddakebono/BTKSAUtils
        // as that sorts all the smoothing out for you (no avatar side work needed)
        #region smoothing logic
        // TODO: // section to handle CVR Fury Smoothed Parameters
        // check and see if the module has any smoothed parameters
        // if ((module as fullControllerModule).smoothedPrms.Count > 0)
        // {
        //   // loop through the smoothed parameters in the module
        //   foreach (
        //     fullControllerModule.SmoothParamEntry smoothedParamEntry in (module as fullControllerModule).smoothedPrms
        //   )
        //   {
        //     // log the smoothed parameter's name to the console
        //     CoreLog("smoothedParamEntry.name: " + smoothedParamEntry.name);

        //     // TODO
        //   }
        // }
        #endregion

        // TODO: // section to handle CVR Fury Toggle Parameter
        // not sure how this could be done as CVR has a flat menu structure, and thus no toggles linked to menu sections
        // need to add a warning if the module has a toggle parameter
        #region Toggle Parameter
        // check and see if the module has a toggle parameter
        // if (!string.IsNullOrWhiteSpace((module as fullControllerModule).toggleParam))
        // {
        //   // log the toggle parameter's name to the console
        //   CoreLog("toggleParam: " + (module as fullControllerModule).toggleParam);
        // }
        #endregion
      }
      else
      {
        // if it doesn't, log an error to the console
        CoreLogError("Avatar does not exist");
      }
    }

    //// -------------------------------------------- supporting functions ---------------------------------------------
    #region supporting functions
    // general functions

    private List<string> getGlobalParameters(CVRFuryModule module)
    {
      // check if can cast the module to fullControllerModule
      if (!(module is fullControllerModule))
      {
        // if it can't, log an error to the console
        CoreLogError("Module is not a fullControllerModule");
        // return an empty list
        return new List<string>();
      }

      // concatenate the global parameters from the module with the global parameters from the
      // constants class to get a list of all global parameters
      // note: source parameters constants are:
      //  - ALWAYS_GLOBAL_PARAMETERS_FROM_CVR
      // and
      //  - ALWAYS_GLOBAL_PARAMETERS_FROM_VRC
      // this is to ensure all parameters people expect to be global are global
      // only add the ones from VRC if the module is marked as imported from VRCFury (importedFromVRCFury)
      List<string> globalParams = (module as fullControllerModule).globalParams
        .Concat(Constants.ALWAYS_GLOBAL_PARAMETERS_FROM_CVR)
        .Concat(
          (module as fullControllerModule).importedFromVRCFury
            ? Constants.ALWAYS_GLOBAL_PARAMETERS_FROM_VRC
            : new List<string>()
        )
        .ToList();

      // de-dupe the global parameters list
      globalParams = globalParams.Distinct().ToList();

      // console print the global parameters list count
      CoreLogDebug("globalParams.Count: " + globalParams.Count);
      // return the list of global parameters
      return globalParams;
    }

    // function to get clips from a blend tree
    List<AnimationClip> GetClipsFromBlendTree(BlendTree blendTree)
    {
      List<AnimationClip> clips = new List<AnimationClip>();

      foreach (var child in blendTree.children)
      {
        if (child.motion is BlendTree childBlendTree)
        {
          // if the child is a blend tree, get the clips from it
          clips.AddRange(GetClipsFromBlendTree(childBlendTree));
        }
        else if (child.motion is AnimationClip clip)
        {
          // if the child is a clip, add it to the list
          clips.Add(clip);
        }
      }

      return clips;
    }

    void ReplaceClipInBlendTree(
      BlendTree blendTree,
      AnimationClip clip,
      AnimationClip tempClip,
      string tempClipPath,
      fullControllerModule.BindingRewrite rewrite
    )
    {
      // Create a new array to hold the modified ChildMotion objects
      ChildMotion[] newChildren = new ChildMotion[blendTree.children.Length];
    
      for (int i = 0; i < blendTree.children.Length; i++)
      {
        var child = blendTree.children[i];
    
        // if the child's motion is the original clip, replace it with the temp clip
        if (child.motion == clip)
        {
          if (rewrite.delete)
          {
            rewrite.to = "";
          }
    
          // use the rewriteAnimationClipCurvePaths function to rewrite the animation clip curve paths
          tempClip = rewriteAnimationClipCurvePaths(tempClip, rewrite.from, rewrite.to);
    
          // mark the tempClip as dirty
          EditorUtility.SetDirty(tempClip);
    
          // set the file path as dirty
          AssetDatabase.WriteImportSettingsIfDirty(tempClipPath);
    
          // save the temp clip
          AssetDatabase.SaveAssets();
    
          child.motion = tempClip;
        }
        // if the child's motion is another blendTree, call this function recursively
        else if (child.motion is BlendTree childBlendTree)
        {
          ReplaceClipInBlendTree(childBlendTree, clip, tempClip, tempClipPath, rewrite);
        }
    
        // Add the modified ChildMotion object to the new array
        newChildren[i] = child;
      }
    
      // Set the children property of the BlendTree to the new array
      blendTree.children = newChildren;
    }

    #endregion
    // functions to handle CVR Fury Menu Store bits --------------------------------------------------------------------
    #region  supporting functions for CVR Fury Menu Store

    public string ProcessParameterMachineName(
      Dictionary<string, string> perModuleParametersPairToRename,
      string MachineName
    )
    {
      // check if the parameter's name is in the perModuleParametersPairToRename list
      if (perModuleParametersPairToRename.ContainsKey(MachineName))
      {
        //console print the toggle parameter's name and the value in the perModuleParametersPairToRename list
        CoreLogDebug("input param name: " + MachineName + " -> " + perModuleParametersPairToRename[MachineName]);

        // if it is, return the value in the perModuleParametersPairToRename list
        return perModuleParametersPairToRename[MachineName];
      }
      else
      {
        // console print the toggle parameter's MachineName
        CoreLog("No change to input param name: " + MachineName);

        // if it isn't, return the toggle parameter's MachineName
        return MachineName;
      }
    }

    #endregion

    #region CVR Fury Menu Store functions

    public void ProcessToggleParameter(
      toggleParameter toggleParam,
      string prefix,
      List<CVRAdvancedSettingsEntry> CVRAdvancedAvatarMenuList,
      Dictionary<string, string> perModuleParametersPairToRename
    )
    {
      // log the toggle parameter's name to the console
      CoreLogDebug("toggleParam.name: " + toggleParam.name);

      // log the toggle parameter's default state to the console
      CoreLogDebug("toggleParam.defaultState: " + toggleParam.defaultState);

      // log the toggle parameter's generate type to the console
      CoreLogDebug("toggleParam.generateType: " + toggleParam.generateType);

      // create CVRAdvancedSettingsEntry for the toggle parameter
      CVRAdvancedSettingsEntry toggleEntry = new CVRAdvancedSettingsEntry();

      // set the CVRAdvancedSettingsEntry's type to SettingsType.GameObjectToggle
      toggleEntry.type = CVRAdvancedSettingsEntry.SettingsType.GameObjectToggle;

      // set the CVRAdvancedSettingsEntry's name to the toggle parameter's name with the prefix
      toggleEntry.name = prefix + toggleParam.name;

      // process the toggle parameter's MachineName, based on the perModuleParametersPairToRename list
      toggleEntry.machineName = ProcessParameterMachineName(perModuleParametersPairToRename, toggleParam.MachineName);

      // create a new CVRAdvancesAvatarSettingGameObjectToggle
      CVRAdvancesAvatarSettingGameObjectToggle toggleSetting = new CVRAdvancesAvatarSettingGameObjectToggle();

      // set the CVRAdvancesAvatarSettingGameObjectToggle's defaultValue to the toggle parameter's default state
      toggleSetting.defaultValue = toggleParam.defaultState;

      // set the CVRAdvancesAvatarSettingGameObjectToggle's usedType to the toggle parameter's generate type via a cast
      switch (toggleParam.generateType)
      {
        case toggleParameter.GenerateType.Bool:
          toggleSetting.usedType = CVRAdvancesAvatarSettingGameObjectToggle.ParameterType.GenerateBool;
          break;
        case toggleParameter.GenerateType.Float:
          toggleSetting.usedType = CVRAdvancesAvatarSettingGameObjectToggle.ParameterType.GenerateFloat;
          break;
        case toggleParameter.GenerateType.Int:
          toggleSetting.usedType = CVRAdvancesAvatarSettingGameObjectToggle.ParameterType.GenerateInt;
          break;
      }

      // put the CVRAdvancesAvatarSettingGameObjectToggle into the CVRAdvancedSettingsEntry's value
      toggleEntry.setting = toggleSetting;

      // add the CVRAdvancedSettingsEntry to the CVRAdvancedAvatarMenuList
      CVRAdvancedAvatarMenuList.Add(toggleEntry);
    }

    public void ProcessDropdownParameter(
      dropdownParameter dropdownParam,
      string prefix,
      List<CVRAdvancedSettingsEntry> CVRAdvancedAvatarMenuList,
      Dictionary<string, string> perModuleParametersPairToRename
    )
    {
      // log the dropdown parameter's name to the console
      CoreLog("dropdownParam.name: " + dropdownParam.name);

      // create CVRAdvancedSettingsEntry for the dropdown parameter
      CVRAdvancedSettingsEntry dropdownEntry = new CVRAdvancedSettingsEntry();

      // set the CVRAdvancedSettingsEntry's type to SettingsType.GameObjectDropdown
      dropdownEntry.type = CVRAdvancedSettingsEntry.SettingsType.GameObjectDropdown;

      // set the CVRAdvancedSettingsEntry's name to the dropdown parameter's name with the prefix
      dropdownEntry.name = prefix + dropdownParam.name;

      // process the dropdownEntry parameter's MachineName, based on the perModuleParametersPairToRename list
      dropdownEntry.machineName = ProcessParameterMachineName(
        perModuleParametersPairToRename,
        dropdownParam.MachineName
      );

      // create a new CVRAdvancesAvatarSettingGameObjectDropdown
      CVRAdvancesAvatarSettingGameObjectDropdown dropdownSetting = new CVRAdvancesAvatarSettingGameObjectDropdown();

      // set the CVRAdvancesAvatarSettingGameObjectDropdown's defaultValue to the dropdown parameter's default index
      dropdownSetting.defaultValue = dropdownParam.defaultIndex;

      // console print the dropdown parameter's default index
      CoreLog("dropdownParam.defaultIndex: " + dropdownParam.defaultIndex);

      // console print the dropdown parameter's generate type
      CoreLog("dropdownParam.generateType: " + dropdownParam.generateType);

      // set the CVRAdvancesAvatarSettingGameObjectDropdown's usedType to the dropdown parameter's
      // generate type via a cast
      switch (dropdownParam.generateType)
      {
        case dropdownParameter.GenerateType.Float:
          dropdownSetting.usedType = CVRAdvancesAvatarSettingGameObjectDropdown.ParameterType.GenerateFloat;
          break;
        case dropdownParameter.GenerateType.Int:
          dropdownSetting.usedType = CVRAdvancesAvatarSettingGameObjectDropdown.ParameterType.GenerateInt;
          break;
      }

      // create a CVRAdvancedSettingsDropDownEntry list for the dropdownSetting's options
      List<CVRAdvancedSettingsDropDownEntry> dropdownOptions = new List<CVRAdvancedSettingsDropDownEntry>();

      // loop through the dropdownParam's options
      foreach (string option in dropdownParam.dropdownList)
      {
        // create a new CVRAdvancedSettingsDropDownEntry
        CVRAdvancedSettingsDropDownEntry dropdownOption = new CVRAdvancedSettingsDropDownEntry();

        // set the CVRAdvancedSettingsDropDownEntry's name to the option
        dropdownOption.name = option;

        // add the CVRAdvancedSettingsDropDownEntry to the dropdownOptions list
        dropdownOptions.Add(dropdownOption);
      }

      // set the CVRAdvancesAvatarSettingGameObjectDropdown's options to the dropdownOptions list
      dropdownSetting.options = dropdownOptions;

      // put the CVRAdvancesAvatarSettingGameObjectDropdown into the CVRAdvancedSettingsEntry's value
      dropdownEntry.setting = dropdownSetting;

      // add the CVRAdvancedSettingsEntry to the CVRAdvancedAvatarMenuList
      CVRAdvancedAvatarMenuList.Add(dropdownEntry);
    }

    public void ProcessSliderParameter(
      sliderParameter sliderParam,
      string prefix,
      List<CVRAdvancedSettingsEntry> CVRAdvancedAvatarMenuList,
      Dictionary<string, string> perModuleParametersPairToRename
    )
    {
      // log the slider parameter's name to the console
      CoreLog("sliderParam.name: " + sliderParam.name);

      // create CVRAdvancedSettingsEntry for the slider parameter
      CVRAdvancedSettingsEntry sliderEntry = new CVRAdvancedSettingsEntry();

      // set the CVRAdvancedSettingsEntry's type to SettingsType.Slider
      sliderEntry.type = CVRAdvancedSettingsEntry.SettingsType.Slider;

      // set the CVRAdvancedSettingsEntry's name to the slider parameter's name with the prefix
      sliderEntry.name = prefix + sliderParam.name;

      // process the slider parameter's MachineName, based on the perModuleParametersPairToRename list
      sliderEntry.machineName = ProcessParameterMachineName(perModuleParametersPairToRename, sliderParam.MachineName);

      // create a new CVRAdvancesAvatarSettingSlider
      CVRAdvancesAvatarSettingSlider sliderSetting = new CVRAdvancesAvatarSettingSlider();

      // set the CVRAdvancesAvatarSettingSlider's defaultValue to the slider parameter's default value
      sliderSetting.defaultValue = sliderParam.defaultValue;

      // put the CVRAdvancesAvatarSettingSlider into the CVRAdvancedSettingsEntry's value
      sliderEntry.setting = sliderSetting;

      // add the CVRAdvancedSettingsEntry to the CVRAdvancedAvatarMenuList
      CVRAdvancedAvatarMenuList.Add(sliderEntry);
    }

    public void ProcessTwoDJoystickParameter(
      twoDJoystickParameter twoDJoystickParam,
      string prefix,
      List<CVRAdvancedSettingsEntry> CVRAdvancedAvatarMenuList,
      Dictionary<string, string> perModuleParametersPairToRename
    )
    {
      // log the twoDJoystick parameter's name to the console
      CoreLog("twoDJoystickParam.name: " + twoDJoystickParam.name);

      // create CVRAdvancedSettingsEntry for the twoDJoystick parameter
      CVRAdvancedSettingsEntry twoDJoystickEntry = new CVRAdvancedSettingsEntry();

      // set the CVRAdvancedSettingsEntry's type to SettingsType.Joystick2D
      twoDJoystickEntry.type = CVRAdvancedSettingsEntry.SettingsType.Joystick2D;

      // set the CVRAdvancedSettingsEntry's name to the twoDJoystick parameter's name with the prefix
      twoDJoystickEntry.name = prefix + twoDJoystickParam.name;

      // process the twoDJoystick parameter's MachineName, based on the perModuleParametersPairToRename list
      twoDJoystickEntry.machineName = ProcessParameterMachineName(
        perModuleParametersPairToRename,
        twoDJoystickParam.MachineName
      );

      // create a new CVRAdvancesAvatarSettingJoystick2D
      CVRAdvancesAvatarSettingJoystick2D twoDJoystickSetting = new CVRAdvancesAvatarSettingJoystick2D();

      // set the CVRAdvancesAvatarSettingTwoDJoystick's defaultValue to the twoDJoystick parameter's default values
      // note in this case the default value is a Vector2, filled by two floats
      twoDJoystickSetting.defaultValue = new Vector2(twoDJoystickParam.defaultXValue, twoDJoystickParam.defaultYValue);

      // set the minimum pair of values for the twoDJoystick parameter
      twoDJoystickSetting.rangeMin = new Vector2(twoDJoystickParam.minXValue, twoDJoystickParam.minYValue);

      // set the maximum pair of values for the twoDJoystick parameter
      twoDJoystickSetting.rangeMax = new Vector2(twoDJoystickParam.maxXValue, twoDJoystickParam.maxYValue);

      // put the CVRAdvancesAvatarSettingTwoDJoystick into the CVRAdvancedSettingsEntry's value
      twoDJoystickEntry.setting = twoDJoystickSetting;

      // add the CVRAdvancedSettingsEntry to the CVRAdvancedAvatarMenuList
      CVRAdvancedAvatarMenuList.Add(twoDJoystickEntry);
    }

    public void ProcessThreeDJoystickParameter(
      threeDJoystickParameter threeDJoystickParam,
      string prefix,
      List<CVRAdvancedSettingsEntry> CVRAdvancedAvatarMenuList,
      Dictionary<string, string> perModuleParametersPairToRename
    )
    {
      // log the threeDJoystick parameter's name to the console
      CoreLog("threeDJoystickParam.name: " + threeDJoystickParam.name);

      // create CVRAdvancedSettingsEntry for the threeDJoystick parameter
      CVRAdvancedSettingsEntry threeDJoystickEntry = new CVRAdvancedSettingsEntry();

      // set the CVRAdvancedSettingsEntry's type to SettingsType.ThreeDJoystick
      threeDJoystickEntry.type = CVRAdvancedSettingsEntry.SettingsType.Joystick3D;

      // set the CVRAdvancedSettingsEntry's name to the threeDJoystick parameter's name with the prefix
      threeDJoystickEntry.name = prefix + threeDJoystickParam.name;

      // process the threeDJoystick parameter's MachineName, based on the perModuleParametersPairToRename list
      threeDJoystickEntry.machineName = ProcessParameterMachineName(
        perModuleParametersPairToRename,
        threeDJoystickParam.MachineName
      );

      // create a new CVRAdvancesAvatarSettingJoystick3D
      CVRAdvancesAvatarSettingJoystick3D threeDJoystickSetting = new CVRAdvancesAvatarSettingJoystick3D();

      // set the CVRAdvancesAvatarSettingThreeDJoystick's defaultValue to the threeDJoystick parameter's default values
      // note in this case the default value is a Vector3, filled by three floats
      threeDJoystickSetting.defaultValue = new Vector3(
        threeDJoystickParam.defaultXValue,
        threeDJoystickParam.defaultYValue,
        threeDJoystickParam.defaultZValue
      );

      // set the minimum set of values for the threeDJoystick parameter
      threeDJoystickSetting.rangeMin = new Vector3(
        threeDJoystickParam.minXValue,
        threeDJoystickParam.minYValue,
        threeDJoystickParam.minZValue
      );

      // set the maximum set of values for the threeDJoystick parameter
      threeDJoystickSetting.rangeMax = new Vector3(
        threeDJoystickParam.maxXValue,
        threeDJoystickParam.maxYValue,
        threeDJoystickParam.maxZValue
      );

      // put the CVRAdvancesAvatarSettingThreeDJoystick into the CVRAdvancedSettingsEntry's value
      threeDJoystickEntry.setting = threeDJoystickSetting;

      // add the CVRAdvancedSettingsEntry to the CVRAdvancedAvatarMenuList
      CVRAdvancedAvatarMenuList.Add(threeDJoystickEntry);
    }

    #endregion
  }
}
// #endif
